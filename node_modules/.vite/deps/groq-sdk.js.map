{
  "version": 3,
  "sources": ["../../groq-sdk/src/version.ts", "../../groq-sdk/src/_shims/registry.ts", "../../groq-sdk/src/_shims/MultipartBody.ts", "../../groq-sdk/src/_shims/web-runtime.ts", "../../groq-sdk/_shims/index.mjs", "../../groq-sdk/src/error.ts", "../../groq-sdk/src/lib/streaming.ts", "../../groq-sdk/src/uploads.ts", "../../groq-sdk/src/core.ts", "../../groq-sdk/src/resource.ts", "../../groq-sdk/src/resources/audio/transcriptions.ts", "../../groq-sdk/src/resources/audio/translations.ts", "../../groq-sdk/src/resources/audio/audio.ts", "../../groq-sdk/src/resources/batches.ts", "../../groq-sdk/src/resources/chat/completions.ts", "../../groq-sdk/src/resources/chat/chat.ts", "../../groq-sdk/src/resources/completions.ts", "../../groq-sdk/src/resources/embeddings.ts", "../../groq-sdk/src/resources/files.ts", "../../groq-sdk/src/resources/models.ts", "../../groq-sdk/src/index.ts"],
  "sourcesContent": ["export const VERSION = '0.15.0'; // x-release-please-version\r\n", "/**\r\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\r\n */\r\nimport { type RequestOptions } from '../core';\r\n\r\nexport interface Shims {\r\n  kind: string;\r\n  fetch: any;\r\n  Request: any;\r\n  Response: any;\r\n  Headers: any;\r\n  FormData: any;\r\n  Blob: any;\r\n  File: any;\r\n  ReadableStream: any;\r\n  getMultipartRequestOptions: <T = Record<string, unknown>>(\r\n    form: Shims['FormData'],\r\n    opts: RequestOptions<T>,\r\n  ) => Promise<RequestOptions<T>>;\r\n  getDefaultAgent: (url: string) => any;\r\n  fileFromPath:\r\n    | ((path: string, filename?: string, options?: {}) => Promise<Shims['File']>)\r\n    | ((path: string, options?: {}) => Promise<Shims['File']>);\r\n  isFsReadStream: (value: any) => boolean;\r\n}\r\n\r\nexport let auto = false;\r\nexport let kind: Shims['kind'] | undefined = undefined;\r\nexport let fetch: Shims['fetch'] | undefined = undefined;\r\nexport let Request: Shims['Request'] | undefined = undefined;\r\nexport let Response: Shims['Response'] | undefined = undefined;\r\nexport let Headers: Shims['Headers'] | undefined = undefined;\r\nexport let FormData: Shims['FormData'] | undefined = undefined;\r\nexport let Blob: Shims['Blob'] | undefined = undefined;\r\nexport let File: Shims['File'] | undefined = undefined;\r\nexport let ReadableStream: Shims['ReadableStream'] | undefined = undefined;\r\nexport let getMultipartRequestOptions: Shims['getMultipartRequestOptions'] | undefined = undefined;\r\nexport let getDefaultAgent: Shims['getDefaultAgent'] | undefined = undefined;\r\nexport let fileFromPath: Shims['fileFromPath'] | undefined = undefined;\r\nexport let isFsReadStream: Shims['isFsReadStream'] | undefined = undefined;\r\n\r\nexport function setShims(shims: Shims, options: { auto: boolean } = { auto: false }) {\r\n  if (auto) {\r\n    throw new Error(\r\n      `you must \\`import 'groq-sdk/shims/${shims.kind}'\\` before importing anything else from groq-sdk`,\r\n    );\r\n  }\r\n  if (kind) {\r\n    throw new Error(\r\n      `can't \\`import 'groq-sdk/shims/${shims.kind}'\\` after \\`import 'groq-sdk/shims/${kind}'\\``,\r\n    );\r\n  }\r\n  auto = options.auto;\r\n  kind = shims.kind;\r\n  fetch = shims.fetch;\r\n  Request = shims.Request;\r\n  Response = shims.Response;\r\n  Headers = shims.Headers;\r\n  FormData = shims.FormData;\r\n  Blob = shims.Blob;\r\n  File = shims.File;\r\n  ReadableStream = shims.ReadableStream;\r\n  getMultipartRequestOptions = shims.getMultipartRequestOptions;\r\n  getDefaultAgent = shims.getDefaultAgent;\r\n  fileFromPath = shims.fileFromPath;\r\n  isFsReadStream = shims.isFsReadStream;\r\n}\r\n", "/**\r\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\r\n */\r\nexport class MultipartBody {\r\n  constructor(public body: any) {}\r\n  get [Symbol.toStringTag](): string {\r\n    return 'MultipartBody';\r\n  }\r\n}\r\n", "/**\r\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\r\n */\r\nimport { MultipartBody } from './MultipartBody';\r\nimport { type RequestOptions } from '../core';\r\nimport { type Shims } from './registry';\r\n\r\nexport function getRuntime({ manuallyImported }: { manuallyImported?: boolean } = {}): Shims {\r\n  const recommendation =\r\n    manuallyImported ?\r\n      `You may need to use polyfills`\r\n    : `Add one of these imports before your first \\`import â€¦ from 'groq-sdk'\\`:\r\n- \\`import 'groq-sdk/shims/node'\\` (if you're running on Node)\r\n- \\`import 'groq-sdk/shims/web'\\` (otherwise)\r\n`;\r\n\r\n  let _fetch, _Request, _Response, _Headers;\r\n  try {\r\n    // @ts-ignore\r\n    _fetch = fetch;\r\n    // @ts-ignore\r\n    _Request = Request;\r\n    // @ts-ignore\r\n    _Response = Response;\r\n    // @ts-ignore\r\n    _Headers = Headers;\r\n  } catch (error) {\r\n    throw new Error(\r\n      `this environment is missing the following Web Fetch API type: ${\r\n        (error as any).message\r\n      }. ${recommendation}`,\r\n    );\r\n  }\r\n\r\n  return {\r\n    kind: 'web',\r\n    fetch: _fetch,\r\n    Request: _Request,\r\n    Response: _Response,\r\n    Headers: _Headers,\r\n    FormData:\r\n      // @ts-ignore\r\n      typeof FormData !== 'undefined' ? FormData : (\r\n        class FormData {\r\n          // @ts-ignore\r\n          constructor() {\r\n            throw new Error(\r\n              `file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`,\r\n            );\r\n          }\r\n        }\r\n      ),\r\n    Blob:\r\n      typeof Blob !== 'undefined' ? Blob : (\r\n        class Blob {\r\n          constructor() {\r\n            throw new Error(\r\n              `file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`,\r\n            );\r\n          }\r\n        }\r\n      ),\r\n    File:\r\n      // @ts-ignore\r\n      typeof File !== 'undefined' ? File : (\r\n        class File {\r\n          // @ts-ignore\r\n          constructor() {\r\n            throw new Error(\r\n              `file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`,\r\n            );\r\n          }\r\n        }\r\n      ),\r\n    ReadableStream:\r\n      // @ts-ignore\r\n      typeof ReadableStream !== 'undefined' ? ReadableStream : (\r\n        class ReadableStream {\r\n          // @ts-ignore\r\n          constructor() {\r\n            throw new Error(\r\n              `streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`,\r\n            );\r\n          }\r\n        }\r\n      ),\r\n    getMultipartRequestOptions: async <T = Record<string, unknown>>(\r\n      // @ts-ignore\r\n      form: FormData,\r\n      opts: RequestOptions<T>,\r\n    ): Promise<RequestOptions<T>> => ({\r\n      ...opts,\r\n      body: new MultipartBody(form) as any,\r\n    }),\r\n    getDefaultAgent: (url: string) => undefined,\r\n    fileFromPath: () => {\r\n      throw new Error(\r\n        'The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/groq/groq-typescript#file-uploads',\r\n      );\r\n    },\r\n    isFsReadStream: (value: any) => false,\r\n  };\r\n}\r\n", "/**\r\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\r\n */\r\nimport * as shims from './registry.mjs';\r\nimport * as auto from 'groq-sdk/_shims/auto/runtime';\r\nif (!shims.kind) shims.setShims(auto.getRuntime(), { auto: true });\r\nexport * from './registry.mjs';\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { castToError, Headers } from './core';\r\n\r\nexport class GroqError extends Error {}\r\n\r\nexport class APIError<\r\n  TStatus extends number | undefined = number | undefined,\r\n  THeaders extends Headers | undefined = Headers | undefined,\r\n  TError extends Object | undefined = Object | undefined,\r\n> extends GroqError {\r\n  /** HTTP status for the response that caused the error */\r\n  readonly status: TStatus;\r\n  /** HTTP headers for the response that caused the error */\r\n  readonly headers: THeaders;\r\n  /** JSON body of the response that caused the error */\r\n  readonly error: TError;\r\n\r\n  constructor(status: TStatus, error: TError, message: string | undefined, headers: THeaders) {\r\n    super(`${APIError.makeMessage(status, error, message)}`);\r\n    this.status = status;\r\n    this.headers = headers;\r\n    this.error = error;\r\n  }\r\n\r\n  private static makeMessage(status: number | undefined, error: any, message: string | undefined) {\r\n    const msg =\r\n      error?.message ?\r\n        typeof error.message === 'string' ?\r\n          error.message\r\n        : JSON.stringify(error.message)\r\n      : error ? JSON.stringify(error)\r\n      : message;\r\n\r\n    if (status && msg) {\r\n      return `${status} ${msg}`;\r\n    }\r\n    if (status) {\r\n      return `${status} status code (no body)`;\r\n    }\r\n    if (msg) {\r\n      return msg;\r\n    }\r\n    return '(no status code or body)';\r\n  }\r\n\r\n  static generate(\r\n    status: number | undefined,\r\n    errorResponse: Object | undefined,\r\n    message: string | undefined,\r\n    headers: Headers | undefined,\r\n  ): APIError {\r\n    if (!status || !headers) {\r\n      return new APIConnectionError({ message, cause: castToError(errorResponse) });\r\n    }\r\n\r\n    const error = errorResponse as Record<string, any>;\r\n\r\n    if (status === 400) {\r\n      return new BadRequestError(status, error, message, headers);\r\n    }\r\n\r\n    if (status === 401) {\r\n      return new AuthenticationError(status, error, message, headers);\r\n    }\r\n\r\n    if (status === 403) {\r\n      return new PermissionDeniedError(status, error, message, headers);\r\n    }\r\n\r\n    if (status === 404) {\r\n      return new NotFoundError(status, error, message, headers);\r\n    }\r\n\r\n    if (status === 409) {\r\n      return new ConflictError(status, error, message, headers);\r\n    }\r\n\r\n    if (status === 422) {\r\n      return new UnprocessableEntityError(status, error, message, headers);\r\n    }\r\n\r\n    if (status === 429) {\r\n      return new RateLimitError(status, error, message, headers);\r\n    }\r\n\r\n    if (status >= 500) {\r\n      return new InternalServerError(status, error, message, headers);\r\n    }\r\n\r\n    return new APIError(status, error, message, headers);\r\n  }\r\n}\r\n\r\nexport class APIUserAbortError extends APIError<undefined, undefined, undefined> {\r\n  constructor({ message }: { message?: string } = {}) {\r\n    super(undefined, undefined, message || 'Request was aborted.', undefined);\r\n  }\r\n}\r\n\r\nexport class APIConnectionError extends APIError<undefined, undefined, undefined> {\r\n  constructor({ message, cause }: { message?: string | undefined; cause?: Error | undefined }) {\r\n    super(undefined, undefined, message || 'Connection error.', undefined);\r\n    // in some environments the 'cause' property is already declared\r\n    // @ts-ignore\r\n    if (cause) this.cause = cause;\r\n  }\r\n}\r\n\r\nexport class APIConnectionTimeoutError extends APIConnectionError {\r\n  constructor({ message }: { message?: string } = {}) {\r\n    super({ message: message ?? 'Request timed out.' });\r\n  }\r\n}\r\n\r\nexport class BadRequestError extends APIError<400, Headers> {}\r\n\r\nexport class AuthenticationError extends APIError<401, Headers> {}\r\n\r\nexport class PermissionDeniedError extends APIError<403, Headers> {}\r\n\r\nexport class NotFoundError extends APIError<404, Headers> {}\r\n\r\nexport class ConflictError extends APIError<409, Headers> {}\r\n\r\nexport class UnprocessableEntityError extends APIError<422, Headers> {}\r\n\r\nexport class RateLimitError extends APIError<429, Headers> {}\r\n\r\nexport class InternalServerError extends APIError<number, Headers> {}\r\n", "import { ReadableStream, type Response } from '../_shims/index';\r\nimport { GroqError } from '../error';\r\n\r\nimport { APIError } from '../error';\r\n\r\ntype Bytes = string | ArrayBuffer | Uint8Array | Buffer | null | undefined;\r\n\r\nexport type ServerSentEvent = {\r\n  event: string | null;\r\n  data: string;\r\n  raw: string[];\r\n};\r\n\r\nexport class Stream<Item> implements AsyncIterable<Item> {\r\n  controller: AbortController;\r\n\r\n  constructor(\r\n    private iterator: () => AsyncIterator<Item>,\r\n    controller: AbortController,\r\n  ) {\r\n    this.controller = controller;\r\n  }\r\n\r\n  static fromSSEResponse<Item>(response: Response, controller: AbortController) {\r\n    let consumed = false;\r\n    const decoder = new SSEDecoder();\r\n\r\n    async function* iterMessages(): AsyncGenerator<ServerSentEvent, void, unknown> {\r\n      if (!response.body) {\r\n        controller.abort();\r\n        throw new GroqError(`Attempted to iterate over a response with no body`);\r\n      }\r\n\r\n      const lineDecoder = new LineDecoder();\r\n\r\n      const iter = readableStreamAsyncIterable<Bytes>(response.body);\r\n      for await (const chunk of iter) {\r\n        for (const line of lineDecoder.decode(chunk)) {\r\n          const sse = decoder.decode(line);\r\n          if (sse) yield sse;\r\n        }\r\n      }\r\n\r\n      for (const line of lineDecoder.flush()) {\r\n        const sse = decoder.decode(line);\r\n        if (sse) yield sse;\r\n      }\r\n    }\r\n\r\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\r\n      if (consumed) {\r\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\r\n      }\r\n      consumed = true;\r\n      let done = false;\r\n      try {\r\n        for await (const sse of iterMessages()) {\r\n          if (done) continue;\r\n\r\n          if (sse.data.startsWith('[DONE]')) {\r\n            done = true;\r\n            continue;\r\n          }\r\n\r\n          if (sse.event === null || sse.event === 'error') {\r\n            let data;\r\n\r\n            try {\r\n              data = JSON.parse(sse.data);\r\n            } catch (e) {\r\n              console.error(`Could not parse message into JSON:`, sse.data);\r\n              console.error(`From chunk:`, sse.raw);\r\n              throw e;\r\n            }\r\n\r\n            if (data && data.error) {\r\n              throw new APIError(data.error.status_code, data.error, data.error.message, undefined);\r\n            }\r\n\r\n            yield data;\r\n          }\r\n        }\r\n        done = true;\r\n      } catch (e) {\r\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\r\n        if (e instanceof Error && e.name === 'AbortError') return;\r\n        throw e;\r\n      } finally {\r\n        // If the user `break`s, abort the ongoing request.\r\n        if (!done) controller.abort();\r\n      }\r\n    }\r\n\r\n    return new Stream(iterator, controller);\r\n  }\r\n\r\n  /**\r\n   * Generates a Stream from a newline-separated ReadableStream\r\n   * where each item is a JSON value.\r\n   */\r\n  static fromReadableStream<Item>(readableStream: ReadableStream, controller: AbortController) {\r\n    let consumed = false;\r\n\r\n    async function* iterLines(): AsyncGenerator<string, void, unknown> {\r\n      const lineDecoder = new LineDecoder();\r\n\r\n      const iter = readableStreamAsyncIterable<Bytes>(readableStream);\r\n      for await (const chunk of iter) {\r\n        for (const line of lineDecoder.decode(chunk)) {\r\n          yield line;\r\n        }\r\n      }\r\n\r\n      for (const line of lineDecoder.flush()) {\r\n        yield line;\r\n      }\r\n    }\r\n\r\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\r\n      if (consumed) {\r\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\r\n      }\r\n      consumed = true;\r\n      let done = false;\r\n      try {\r\n        for await (const line of iterLines()) {\r\n          if (done) continue;\r\n          if (line) yield JSON.parse(line);\r\n        }\r\n        done = true;\r\n      } catch (e) {\r\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\r\n        if (e instanceof Error && e.name === 'AbortError') return;\r\n        throw e;\r\n      } finally {\r\n        // If the user `break`s, abort the ongoing request.\r\n        if (!done) controller.abort();\r\n      }\r\n    }\r\n\r\n    return new Stream(iterator, controller);\r\n  }\r\n\r\n  [Symbol.asyncIterator](): AsyncIterator<Item> {\r\n    return this.iterator();\r\n  }\r\n\r\n  /**\r\n   * Splits the stream into two streams which can be\r\n   * independently read from at different speeds.\r\n   */\r\n  tee(): [Stream<Item>, Stream<Item>] {\r\n    const left: Array<Promise<IteratorResult<Item>>> = [];\r\n    const right: Array<Promise<IteratorResult<Item>>> = [];\r\n    const iterator = this.iterator();\r\n\r\n    const teeIterator = (queue: Array<Promise<IteratorResult<Item>>>): AsyncIterator<Item> => {\r\n      return {\r\n        next: () => {\r\n          if (queue.length === 0) {\r\n            const result = iterator.next();\r\n            left.push(result);\r\n            right.push(result);\r\n          }\r\n          return queue.shift()!;\r\n        },\r\n      };\r\n    };\r\n\r\n    return [\r\n      new Stream(() => teeIterator(left), this.controller),\r\n      new Stream(() => teeIterator(right), this.controller),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Converts this stream to a newline-separated ReadableStream of\r\n   * JSON stringified values in the stream\r\n   * which can be turned back into a Stream with `Stream.fromReadableStream()`.\r\n   */\r\n  toReadableStream(): ReadableStream {\r\n    const self = this;\r\n    let iter: AsyncIterator<Item>;\r\n    const encoder = new TextEncoder();\r\n\r\n    return new ReadableStream({\r\n      async start() {\r\n        iter = self[Symbol.asyncIterator]();\r\n      },\r\n      async pull(ctrl) {\r\n        try {\r\n          const { value, done } = await iter.next();\r\n          if (done) return ctrl.close();\r\n\r\n          const bytes = encoder.encode(JSON.stringify(value) + '\\n');\r\n\r\n          ctrl.enqueue(bytes);\r\n        } catch (err) {\r\n          ctrl.error(err);\r\n        }\r\n      },\r\n      async cancel() {\r\n        await iter.return?.();\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nclass SSEDecoder {\r\n  private data: string[];\r\n  private event: string | null;\r\n  private chunks: string[];\r\n\r\n  constructor() {\r\n    this.event = null;\r\n    this.data = [];\r\n    this.chunks = [];\r\n  }\r\n\r\n  decode(line: string) {\r\n    if (line.endsWith('\\r')) {\r\n      line = line.substring(0, line.length - 1);\r\n    }\r\n\r\n    if (!line) {\r\n      // empty line and we didn't previously encounter any messages\r\n      if (!this.event && !this.data.length) return null;\r\n\r\n      const sse: ServerSentEvent = {\r\n        event: this.event,\r\n        data: this.data.join('\\n'),\r\n        raw: this.chunks,\r\n      };\r\n\r\n      this.event = null;\r\n      this.data = [];\r\n      this.chunks = [];\r\n\r\n      return sse;\r\n    }\r\n\r\n    this.chunks.push(line);\r\n\r\n    if (line.startsWith(':')) {\r\n      return null;\r\n    }\r\n\r\n    let [fieldname, _, value] = partition(line, ':');\r\n\r\n    if (value.startsWith(' ')) {\r\n      value = value.substring(1);\r\n    }\r\n\r\n    if (fieldname === 'event') {\r\n      this.event = value;\r\n    } else if (fieldname === 'data') {\r\n      this.data.push(value);\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\r\n * reading lines from text.\r\n *\r\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\r\n */\r\nclass LineDecoder {\r\n  // prettier-ignore\r\n  static NEWLINE_CHARS = new Set(['\\n', '\\r', '\\x0b', '\\x0c', '\\x1c', '\\x1d', '\\x1e', '\\x85', '\\u2028', '\\u2029']);\r\n  static NEWLINE_REGEXP = /\\r\\n|[\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/g;\r\n\r\n  buffer: string[];\r\n  trailingCR: boolean;\r\n  textDecoder: any; // TextDecoder found in browsers; not typed to avoid pulling in either \"dom\" or \"node\" types.\r\n\r\n  constructor() {\r\n    this.buffer = [];\r\n    this.trailingCR = false;\r\n  }\r\n\r\n  decode(chunk: Bytes): string[] {\r\n    let text = this.decodeText(chunk);\r\n\r\n    if (this.trailingCR) {\r\n      text = '\\r' + text;\r\n      this.trailingCR = false;\r\n    }\r\n    if (text.endsWith('\\r')) {\r\n      this.trailingCR = true;\r\n      text = text.slice(0, -1);\r\n    }\r\n\r\n    if (!text) {\r\n      return [];\r\n    }\r\n\r\n    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');\r\n    let lines = text.split(LineDecoder.NEWLINE_REGEXP);\r\n\r\n    if (lines.length === 1 && !trailingNewline) {\r\n      this.buffer.push(lines[0]!);\r\n      return [];\r\n    }\r\n\r\n    if (this.buffer.length > 0) {\r\n      lines = [this.buffer.join('') + lines[0], ...lines.slice(1)];\r\n      this.buffer = [];\r\n    }\r\n\r\n    if (!trailingNewline) {\r\n      this.buffer = [lines.pop() || ''];\r\n    }\r\n\r\n    return lines;\r\n  }\r\n\r\n  decodeText(bytes: Bytes): string {\r\n    if (bytes == null) return '';\r\n    if (typeof bytes === 'string') return bytes;\r\n\r\n    // Node:\r\n    if (typeof Buffer !== 'undefined') {\r\n      if (bytes instanceof Buffer) {\r\n        return bytes.toString();\r\n      }\r\n      if (bytes instanceof Uint8Array) {\r\n        return Buffer.from(bytes).toString();\r\n      }\r\n\r\n      throw new GroqError(\r\n        `Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`,\r\n      );\r\n    }\r\n\r\n    // Browser\r\n    if (typeof TextDecoder !== 'undefined') {\r\n      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\r\n        this.textDecoder ??= new TextDecoder('utf8');\r\n        return this.textDecoder.decode(bytes);\r\n      }\r\n\r\n      throw new GroqError(\r\n        `Unexpected: received non-Uint8Array/ArrayBuffer (${\r\n          (bytes as any).constructor.name\r\n        }) in a web platform. Please report this error.`,\r\n      );\r\n    }\r\n\r\n    throw new GroqError(\r\n      `Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`,\r\n    );\r\n  }\r\n\r\n  flush(): string[] {\r\n    if (!this.buffer.length && !this.trailingCR) {\r\n      return [];\r\n    }\r\n\r\n    const lines = [this.buffer.join('')];\r\n    this.buffer = [];\r\n    this.trailingCR = false;\r\n    return lines;\r\n  }\r\n}\r\n\r\nfunction partition(str: string, delimiter: string): [string, string, string] {\r\n  const index = str.indexOf(delimiter);\r\n  if (index !== -1) {\r\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\r\n  }\r\n\r\n  return [str, '', ''];\r\n}\r\n\r\n/**\r\n * Most browsers don't yet have async iterable support for ReadableStream,\r\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\r\n *\r\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\r\n */\r\nexport function readableStreamAsyncIterable<T>(stream: any): AsyncIterableIterator<T> {\r\n  if (stream[Symbol.asyncIterator]) return stream;\r\n\r\n  const reader = stream.getReader();\r\n  return {\r\n    async next() {\r\n      try {\r\n        const result = await reader.read();\r\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\r\n        return result;\r\n      } catch (e) {\r\n        reader.releaseLock(); // release lock when stream becomes errored\r\n        throw e;\r\n      }\r\n    },\r\n    async return() {\r\n      const cancelPromise = reader.cancel();\r\n      reader.releaseLock();\r\n      await cancelPromise;\r\n      return { done: true, value: undefined };\r\n    },\r\n    [Symbol.asyncIterator]() {\r\n      return this;\r\n    },\r\n  };\r\n}\r\n", "import { type RequestOptions } from './core';\r\nimport {\r\n  FormData,\r\n  File,\r\n  type Blob,\r\n  type FilePropertyBag,\r\n  getMultipartRequestOptions,\r\n  type FsReadStream,\r\n  isFsReadStream,\r\n} from './_shims/index';\r\nimport { MultipartBody } from './_shims/MultipartBody';\r\nexport { fileFromPath } from './_shims/index';\r\n\r\ntype BlobLikePart = string | ArrayBuffer | ArrayBufferView | BlobLike | Uint8Array | DataView;\r\nexport type BlobPart = string | ArrayBuffer | ArrayBufferView | Blob | Uint8Array | DataView;\r\n\r\n/**\r\n * Typically, this is a native \"File\" class.\r\n *\r\n * We provide the {@link toFile} utility to convert a variety of objects\r\n * into the File class.\r\n *\r\n * For convenience, you can also pass a fetch Response, or in Node,\r\n * the result of fs.createReadStream().\r\n */\r\nexport type Uploadable = FileLike | ResponseLike | FsReadStream;\r\n\r\n/**\r\n * Intended to match web.Blob, node.Blob, node-fetch.Blob, etc.\r\n */\r\nexport interface BlobLike {\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/size) */\r\n  readonly size: number;\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/type) */\r\n  readonly type: string;\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/text) */\r\n  text(): Promise<string>;\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/slice) */\r\n  slice(start?: number, end?: number): BlobLike;\r\n  // unfortunately @types/node-fetch@^2.6.4 doesn't type the arrayBuffer method\r\n}\r\n\r\n/**\r\n * Intended to match web.File, node.File, node-fetch.File, etc.\r\n */\r\nexport interface FileLike extends BlobLike {\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/lastModified) */\r\n  readonly lastModified: number;\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/name) */\r\n  readonly name: string;\r\n}\r\n\r\n/**\r\n * Intended to match web.Response, node.Response, node-fetch.Response, etc.\r\n */\r\nexport interface ResponseLike {\r\n  url: string;\r\n  blob(): Promise<BlobLike>;\r\n}\r\n\r\nexport const isResponseLike = (value: any): value is ResponseLike =>\r\n  value != null &&\r\n  typeof value === 'object' &&\r\n  typeof value.url === 'string' &&\r\n  typeof value.blob === 'function';\r\n\r\nexport const isFileLike = (value: any): value is FileLike =>\r\n  value != null &&\r\n  typeof value === 'object' &&\r\n  typeof value.name === 'string' &&\r\n  typeof value.lastModified === 'number' &&\r\n  isBlobLike(value);\r\n\r\n/**\r\n * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check\r\n * adds the arrayBuffer() method type because it is available and used at runtime\r\n */\r\nexport const isBlobLike = (value: any): value is BlobLike & { arrayBuffer(): Promise<ArrayBuffer> } =>\r\n  value != null &&\r\n  typeof value === 'object' &&\r\n  typeof value.size === 'number' &&\r\n  typeof value.type === 'string' &&\r\n  typeof value.text === 'function' &&\r\n  typeof value.slice === 'function' &&\r\n  typeof value.arrayBuffer === 'function';\r\n\r\nexport const isUploadable = (value: any): value is Uploadable => {\r\n  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);\r\n};\r\n\r\nexport type ToFileInput = Uploadable | Exclude<BlobLikePart, string> | AsyncIterable<BlobLikePart>;\r\n\r\n/**\r\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\r\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\r\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\r\n * @param {Object=} options additional properties\r\n * @param {string=} options.type the MIME type of the content\r\n * @param {number=} options.lastModified the last modified timestamp\r\n * @returns a {@link File} with the given properties\r\n */\r\nexport async function toFile(\r\n  value: ToFileInput | PromiseLike<ToFileInput>,\r\n  name?: string | null | undefined,\r\n  options?: FilePropertyBag | undefined,\r\n): Promise<FileLike> {\r\n  // If it's a promise, resolve it.\r\n  value = await value;\r\n\r\n  // If we've been given a `File` we don't need to do anything\r\n  if (isFileLike(value)) {\r\n    return value;\r\n  }\r\n\r\n  if (isResponseLike(value)) {\r\n    const blob = await value.blob();\r\n    name ||= new URL(value.url).pathname.split(/[\\\\/]/).pop() ?? 'unknown_file';\r\n\r\n    // we need to convert the `Blob` into an array buffer because the `Blob` class\r\n    // that `node-fetch` defines is incompatible with the web standard which results\r\n    // in `new File` interpreting it as a string instead of binary data.\r\n    const data = isBlobLike(blob) ? [(await blob.arrayBuffer()) as any] : [blob];\r\n\r\n    return new File(data, name, options);\r\n  }\r\n\r\n  const bits = await getBytes(value);\r\n\r\n  name ||= getName(value) ?? 'unknown_file';\r\n\r\n  if (!options?.type) {\r\n    const type = (bits[0] as any)?.type;\r\n    if (typeof type === 'string') {\r\n      options = { ...options, type };\r\n    }\r\n  }\r\n\r\n  return new File(bits, name, options);\r\n}\r\n\r\nasync function getBytes(value: ToFileInput): Promise<Array<BlobPart>> {\r\n  let parts: Array<BlobPart> = [];\r\n  if (\r\n    typeof value === 'string' ||\r\n    ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\r\n    value instanceof ArrayBuffer\r\n  ) {\r\n    parts.push(value);\r\n  } else if (isBlobLike(value)) {\r\n    parts.push(await value.arrayBuffer());\r\n  } else if (\r\n    isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.\r\n  ) {\r\n    for await (const chunk of value) {\r\n      parts.push(chunk as BlobPart); // TODO, consider validating?\r\n    }\r\n  } else {\r\n    throw new Error(\r\n      `Unexpected data type: ${typeof value}; constructor: ${value?.constructor\r\n        ?.name}; props: ${propsForError(value)}`,\r\n    );\r\n  }\r\n\r\n  return parts;\r\n}\r\n\r\nfunction propsForError(value: any): string {\r\n  const props = Object.getOwnPropertyNames(value);\r\n  return `[${props.map((p) => `\"${p}\"`).join(', ')}]`;\r\n}\r\n\r\nfunction getName(value: any): string | undefined {\r\n  return (\r\n    getStringFromMaybeBuffer(value.name) ||\r\n    getStringFromMaybeBuffer(value.filename) ||\r\n    // For fs.ReadStream\r\n    getStringFromMaybeBuffer(value.path)?.split(/[\\\\/]/).pop()\r\n  );\r\n}\r\n\r\nconst getStringFromMaybeBuffer = (x: string | Buffer | unknown): string | undefined => {\r\n  if (typeof x === 'string') return x;\r\n  if (typeof Buffer !== 'undefined' && x instanceof Buffer) return String(x);\r\n  return undefined;\r\n};\r\n\r\nconst isAsyncIterableIterator = (value: any): value is AsyncIterableIterator<unknown> =>\r\n  value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\r\n\r\nexport const isMultipartBody = (body: any): body is MultipartBody =>\r\n  body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';\r\n\r\n/**\r\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\r\n * Otherwise returns the request as is.\r\n */\r\nexport const maybeMultipartFormRequestOptions = async <T = Record<string, unknown>>(\r\n  opts: RequestOptions<T>,\r\n): Promise<RequestOptions<T | MultipartBody>> => {\r\n  if (!hasUploadableValue(opts.body)) return opts;\r\n\r\n  const form = await createForm(opts.body);\r\n  return getMultipartRequestOptions(form, opts);\r\n};\r\n\r\nexport const multipartFormRequestOptions = async <T = Record<string, unknown>>(\r\n  opts: RequestOptions<T>,\r\n): Promise<RequestOptions<T | MultipartBody>> => {\r\n  const form = await createForm(opts.body);\r\n  return getMultipartRequestOptions(form, opts);\r\n};\r\n\r\nexport const createForm = async <T = Record<string, unknown>>(body: T | undefined): Promise<FormData> => {\r\n  const form = new FormData();\r\n  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\r\n  return form;\r\n};\r\n\r\nconst hasUploadableValue = (value: unknown): boolean => {\r\n  if (isUploadable(value)) return true;\r\n  if (Array.isArray(value)) return value.some(hasUploadableValue);\r\n  if (value && typeof value === 'object') {\r\n    for (const k in value) {\r\n      if (hasUploadableValue((value as any)[k])) return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nconst addFormValue = async (form: FormData, key: string, value: unknown): Promise<void> => {\r\n  if (value === undefined) return;\r\n  if (value == null) {\r\n    throw new TypeError(\r\n      `Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`,\r\n    );\r\n  }\r\n\r\n  // TODO: make nested formats configurable\r\n  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\r\n    form.append(key, String(value));\r\n  } else if (isUploadable(value)) {\r\n    const file = await toFile(value);\r\n    form.append(key, file as File);\r\n  } else if (Array.isArray(value)) {\r\n    await Promise.all(value.map((entry) => addFormValue(form, key + '[]', entry)));\r\n  } else if (typeof value === 'object') {\r\n    await Promise.all(\r\n      Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)),\r\n    );\r\n  } else {\r\n    throw new TypeError(\r\n      `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`,\r\n    );\r\n  }\r\n};\r\n", "import { VERSION } from './version';\r\nimport { Stream } from './lib/streaming';\r\nimport {\r\n  GroqError,\r\n  APIError,\r\n  APIConnectionError,\r\n  APIConnectionTimeoutError,\r\n  APIUserAbortError,\r\n} from './error';\r\nimport {\r\n  kind as shimsKind,\r\n  type Readable,\r\n  getDefaultAgent,\r\n  type Agent,\r\n  fetch,\r\n  type RequestInfo,\r\n  type RequestInit,\r\n  type Response,\r\n  type HeadersInit,\r\n} from './_shims/index';\r\nexport { type Response };\r\nimport { BlobLike, isBlobLike, isMultipartBody } from './uploads';\r\nexport {\r\n  maybeMultipartFormRequestOptions,\r\n  multipartFormRequestOptions,\r\n  createForm,\r\n  type Uploadable,\r\n} from './uploads';\r\n\r\nexport type Fetch = (url: RequestInfo, init?: RequestInit) => Promise<Response>;\r\n\r\ntype PromiseOrValue<T> = T | Promise<T>;\r\n\r\ntype APIResponseProps = {\r\n  response: Response;\r\n  options: FinalRequestOptions;\r\n  controller: AbortController;\r\n};\r\n\r\nasync function defaultParseResponse<T>(props: APIResponseProps): Promise<T> {\r\n  const { response } = props;\r\n  if (props.options.stream) {\r\n    debug('response', response.status, response.url, response.headers, response.body);\r\n\r\n    // Note: there is an invariant here that isn't represented in the type system\r\n    // that if you set `stream: true` the response type must also be `Stream<T>`\r\n\r\n    if (props.options.__streamClass) {\r\n      return props.options.__streamClass.fromSSEResponse(response, props.controller) as any;\r\n    }\r\n\r\n    return Stream.fromSSEResponse(response, props.controller) as any;\r\n  }\r\n\r\n  // fetch refuses to read the body when the status code is 204.\r\n  if (response.status === 204) {\r\n    return null as T;\r\n  }\r\n\r\n  if (props.options.__binaryResponse) {\r\n    return response as unknown as T;\r\n  }\r\n\r\n  const contentType = response.headers.get('content-type');\r\n  const isJSON =\r\n    contentType?.includes('application/json') || contentType?.includes('application/vnd.api+json');\r\n  if (isJSON) {\r\n    const json = await response.json();\r\n\r\n    debug('response', response.status, response.url, response.headers, json);\r\n\r\n    return json as T;\r\n  }\r\n\r\n  const text = await response.text();\r\n  debug('response', response.status, response.url, response.headers, text);\r\n\r\n  // TODO handle blob, arraybuffer, other content types, etc.\r\n  return text as unknown as T;\r\n}\r\n\r\n/**\r\n * A subclass of `Promise` providing additional helper methods\r\n * for interacting with the SDK.\r\n */\r\nexport class APIPromise<T> extends Promise<T> {\r\n  private parsedPromise: Promise<T> | undefined;\r\n\r\n  constructor(\r\n    private responsePromise: Promise<APIResponseProps>,\r\n    private parseResponse: (props: APIResponseProps) => PromiseOrValue<T> = defaultParseResponse,\r\n  ) {\r\n    super((resolve) => {\r\n      // this is maybe a bit weird but this has to be a no-op to not implicitly\r\n      // parse the response body; instead .then, .catch, .finally are overridden\r\n      // to parse the response\r\n      resolve(null as any);\r\n    });\r\n  }\r\n\r\n  _thenUnwrap<U>(transform: (data: T, props: APIResponseProps) => U): APIPromise<U> {\r\n    return new APIPromise(this.responsePromise, async (props) =>\r\n      transform(await this.parseResponse(props), props),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Gets the raw `Response` instance instead of parsing the response\r\n   * data.\r\n   *\r\n   * If you want to parse the response body but still get the `Response`\r\n   * instance, you can use {@link withResponse()}.\r\n   *\r\n   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?\r\n   * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\r\n   * or add one of these imports before your first `import â€¦ from 'groq-sdk'`:\r\n   * - `import 'groq-sdk/shims/node'` (if you're running on Node)\r\n   * - `import 'groq-sdk/shims/web'` (otherwise)\r\n   */\r\n  asResponse(): Promise<Response> {\r\n    return this.responsePromise.then((p) => p.response);\r\n  }\r\n  /**\r\n   * Gets the parsed response data and the raw `Response` instance.\r\n   *\r\n   * If you just want to get the raw `Response` instance without parsing it,\r\n   * you can use {@link asResponse()}.\r\n   *\r\n   *\r\n   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?\r\n   * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\r\n   * or add one of these imports before your first `import â€¦ from 'groq-sdk'`:\r\n   * - `import 'groq-sdk/shims/node'` (if you're running on Node)\r\n   * - `import 'groq-sdk/shims/web'` (otherwise)\r\n   */\r\n  async withResponse(): Promise<{ data: T; response: Response }> {\r\n    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\r\n    return { data, response };\r\n  }\r\n\r\n  private parse(): Promise<T> {\r\n    if (!this.parsedPromise) {\r\n      this.parsedPromise = this.responsePromise.then(this.parseResponse);\r\n    }\r\n    return this.parsedPromise;\r\n  }\r\n\r\n  override then<TResult1 = T, TResult2 = never>(\r\n    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\r\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\r\n  ): Promise<TResult1 | TResult2> {\r\n    return this.parse().then(onfulfilled, onrejected);\r\n  }\r\n\r\n  override catch<TResult = never>(\r\n    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,\r\n  ): Promise<T | TResult> {\r\n    return this.parse().catch(onrejected);\r\n  }\r\n\r\n  override finally(onfinally?: (() => void) | undefined | null): Promise<T> {\r\n    return this.parse().finally(onfinally);\r\n  }\r\n}\r\n\r\nexport abstract class APIClient {\r\n  baseURL: string;\r\n  maxRetries: number;\r\n  timeout: number;\r\n  httpAgent: Agent | undefined;\r\n\r\n  private fetch: Fetch;\r\n  protected idempotencyHeader?: string;\r\n\r\n  constructor({\r\n    baseURL,\r\n    maxRetries = 2,\r\n    timeout = 60000, // 1 minute\r\n    httpAgent,\r\n    fetch: overriddenFetch,\r\n  }: {\r\n    baseURL: string;\r\n    maxRetries?: number | undefined;\r\n    timeout: number | undefined;\r\n    httpAgent: Agent | undefined;\r\n    fetch: Fetch | undefined;\r\n  }) {\r\n    this.baseURL = baseURL;\r\n    this.maxRetries = validatePositiveInteger('maxRetries', maxRetries);\r\n    this.timeout = validatePositiveInteger('timeout', timeout);\r\n    this.httpAgent = httpAgent;\r\n\r\n    this.fetch = overriddenFetch ?? fetch;\r\n  }\r\n\r\n  protected authHeaders(opts: FinalRequestOptions): Headers {\r\n    return {};\r\n  }\r\n\r\n  /**\r\n   * Override this to add your own default headers, for example:\r\n   *\r\n   *  {\r\n   *    ...super.defaultHeaders(),\r\n   *    Authorization: 'Bearer 123',\r\n   *  }\r\n   */\r\n  protected defaultHeaders(opts: FinalRequestOptions): Headers {\r\n    return {\r\n      Accept: 'application/json',\r\n      'Content-Type': 'application/json',\r\n      'User-Agent': this.getUserAgent(),\r\n      ...getPlatformHeaders(),\r\n      ...this.authHeaders(opts),\r\n    };\r\n  }\r\n\r\n  protected abstract defaultQuery(): DefaultQuery | undefined;\r\n\r\n  /**\r\n   * Override this to add your own headers validation:\r\n   */\r\n  protected validateHeaders(headers: Headers, customHeaders: Headers) {}\r\n\r\n  protected defaultIdempotencyKey(): string {\r\n    return `stainless-node-retry-${uuid4()}`;\r\n  }\r\n\r\n  get<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\r\n    return this.methodRequest('get', path, opts);\r\n  }\r\n\r\n  post<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\r\n    return this.methodRequest('post', path, opts);\r\n  }\r\n\r\n  patch<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\r\n    return this.methodRequest('patch', path, opts);\r\n  }\r\n\r\n  put<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\r\n    return this.methodRequest('put', path, opts);\r\n  }\r\n\r\n  delete<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\r\n    return this.methodRequest('delete', path, opts);\r\n  }\r\n\r\n  private methodRequest<Req, Rsp>(\r\n    method: HTTPMethod,\r\n    path: string,\r\n    opts?: PromiseOrValue<RequestOptions<Req>>,\r\n  ): APIPromise<Rsp> {\r\n    return this.request(\r\n      Promise.resolve(opts).then(async (opts) => {\r\n        const body =\r\n          opts && isBlobLike(opts?.body) ? new DataView(await opts.body.arrayBuffer())\r\n          : opts?.body instanceof DataView ? opts.body\r\n          : opts?.body instanceof ArrayBuffer ? new DataView(opts.body)\r\n          : opts && ArrayBuffer.isView(opts?.body) ? new DataView(opts.body.buffer)\r\n          : opts?.body;\r\n        return { method, path, ...opts, body };\r\n      }),\r\n    );\r\n  }\r\n\r\n  getAPIList<Item, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(\r\n    path: string,\r\n    Page: new (...args: any[]) => PageClass,\r\n    opts?: RequestOptions<any>,\r\n  ): PagePromise<PageClass, Item> {\r\n    return this.requestAPIList(Page, { method: 'get', path, ...opts });\r\n  }\r\n\r\n  private calculateContentLength(body: unknown): string | null {\r\n    if (typeof body === 'string') {\r\n      if (typeof Buffer !== 'undefined') {\r\n        return Buffer.byteLength(body, 'utf8').toString();\r\n      }\r\n\r\n      if (typeof TextEncoder !== 'undefined') {\r\n        const encoder = new TextEncoder();\r\n        const encoded = encoder.encode(body);\r\n        return encoded.length.toString();\r\n      }\r\n    } else if (ArrayBuffer.isView(body)) {\r\n      return body.byteLength.toString();\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  buildRequest<Req>(\r\n    options: FinalRequestOptions<Req>,\r\n    { retryCount = 0 }: { retryCount?: number } = {},\r\n  ): { req: RequestInit; url: string; timeout: number } {\r\n    const { method, path, query, headers: headers = {} } = options;\r\n\r\n    const body =\r\n      ArrayBuffer.isView(options.body) || (options.__binaryRequest && typeof options.body === 'string') ?\r\n        options.body\r\n      : isMultipartBody(options.body) ? options.body.body\r\n      : options.body ? JSON.stringify(options.body, null, 2)\r\n      : null;\r\n    const contentLength = this.calculateContentLength(body);\r\n\r\n    const url = this.buildURL(path!, query);\r\n    if ('timeout' in options) validatePositiveInteger('timeout', options.timeout);\r\n    const timeout = options.timeout ?? this.timeout;\r\n    const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);\r\n    const minAgentTimeout = timeout + 1000;\r\n    if (\r\n      typeof (httpAgent as any)?.options?.timeout === 'number' &&\r\n      minAgentTimeout > ((httpAgent as any).options.timeout ?? 0)\r\n    ) {\r\n      // Allow any given request to bump our agent active socket timeout.\r\n      // This may seem strange, but leaking active sockets should be rare and not particularly problematic,\r\n      // and without mutating agent we would need to create more of them.\r\n      // This tradeoff optimizes for performance.\r\n      (httpAgent as any).options.timeout = minAgentTimeout;\r\n    }\r\n\r\n    if (this.idempotencyHeader && method !== 'get') {\r\n      if (!options.idempotencyKey) options.idempotencyKey = this.defaultIdempotencyKey();\r\n      headers[this.idempotencyHeader] = options.idempotencyKey;\r\n    }\r\n\r\n    const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });\r\n\r\n    const req: RequestInit = {\r\n      method,\r\n      ...(body && { body: body as any }),\r\n      headers: reqHeaders,\r\n      ...(httpAgent && { agent: httpAgent }),\r\n      // @ts-ignore node-fetch uses a custom AbortSignal type that is\r\n      // not compatible with standard web types\r\n      signal: options.signal ?? null,\r\n    };\r\n\r\n    return { req, url, timeout };\r\n  }\r\n\r\n  private buildHeaders({\r\n    options,\r\n    headers,\r\n    contentLength,\r\n    retryCount,\r\n  }: {\r\n    options: FinalRequestOptions;\r\n    headers: Record<string, string | null | undefined>;\r\n    contentLength: string | null | undefined;\r\n    retryCount: number;\r\n  }): Record<string, string> {\r\n    const reqHeaders: Record<string, string> = {};\r\n    if (contentLength) {\r\n      reqHeaders['content-length'] = contentLength;\r\n    }\r\n\r\n    const defaultHeaders = this.defaultHeaders(options);\r\n    applyHeadersMut(reqHeaders, defaultHeaders);\r\n    applyHeadersMut(reqHeaders, headers);\r\n\r\n    // let builtin fetch set the Content-Type for multipart bodies\r\n    if (isMultipartBody(options.body) && shimsKind !== 'node') {\r\n      delete reqHeaders['content-type'];\r\n    }\r\n\r\n    // Don't set the retry count header if it was already set or removed through default headers or by the\r\n    // caller. We check `defaultHeaders` and `headers`, which can contain nulls, instead of `reqHeaders` to\r\n    // account for the removal case.\r\n    if (\r\n      getHeader(defaultHeaders, 'x-stainless-retry-count') === undefined &&\r\n      getHeader(headers, 'x-stainless-retry-count') === undefined\r\n    ) {\r\n      reqHeaders['x-stainless-retry-count'] = String(retryCount);\r\n    }\r\n\r\n    this.validateHeaders(reqHeaders, headers);\r\n\r\n    return reqHeaders;\r\n  }\r\n\r\n  /**\r\n   * Used as a callback for mutating the given `FinalRequestOptions` object.\r\n   */\r\n  protected async prepareOptions(options: FinalRequestOptions): Promise<void> {}\r\n\r\n  /**\r\n   * Used as a callback for mutating the given `RequestInit` object.\r\n   *\r\n   * This is useful for cases where you want to add certain headers based off of\r\n   * the request properties, e.g. `method` or `url`.\r\n   */\r\n  protected async prepareRequest(\r\n    request: RequestInit,\r\n    { url, options }: { url: string; options: FinalRequestOptions },\r\n  ): Promise<void> {}\r\n\r\n  protected parseHeaders(headers: HeadersInit | null | undefined): Record<string, string> {\r\n    return (\r\n      !headers ? {}\r\n      : Symbol.iterator in headers ?\r\n        Object.fromEntries(Array.from(headers as Iterable<string[]>).map((header) => [...header]))\r\n      : { ...headers }\r\n    );\r\n  }\r\n\r\n  protected makeStatusError(\r\n    status: number | undefined,\r\n    error: Object | undefined,\r\n    message: string | undefined,\r\n    headers: Headers | undefined,\r\n  ): APIError {\r\n    return APIError.generate(status, error, message, headers);\r\n  }\r\n\r\n  request<Req, Rsp>(\r\n    options: PromiseOrValue<FinalRequestOptions<Req>>,\r\n    remainingRetries: number | null = null,\r\n  ): APIPromise<Rsp> {\r\n    return new APIPromise(this.makeRequest(options, remainingRetries));\r\n  }\r\n\r\n  private async makeRequest<Req>(\r\n    optionsInput: PromiseOrValue<FinalRequestOptions<Req>>,\r\n    retriesRemaining: number | null,\r\n  ): Promise<APIResponseProps> {\r\n    const options = await optionsInput;\r\n    const maxRetries = options.maxRetries ?? this.maxRetries;\r\n    if (retriesRemaining == null) {\r\n      retriesRemaining = maxRetries;\r\n    }\r\n\r\n    await this.prepareOptions(options);\r\n\r\n    const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });\r\n\r\n    await this.prepareRequest(req, { url, options });\r\n\r\n    debug('request', url, options, req.headers);\r\n\r\n    if (options.signal?.aborted) {\r\n      throw new APIUserAbortError();\r\n    }\r\n\r\n    const controller = new AbortController();\r\n    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);\r\n\r\n    if (response instanceof Error) {\r\n      if (options.signal?.aborted) {\r\n        throw new APIUserAbortError();\r\n      }\r\n      if (retriesRemaining) {\r\n        return this.retryRequest(options, retriesRemaining);\r\n      }\r\n      if (response.name === 'AbortError') {\r\n        throw new APIConnectionTimeoutError();\r\n      }\r\n      throw new APIConnectionError({ cause: response });\r\n    }\r\n\r\n    const responseHeaders = createResponseHeaders(response.headers);\r\n\r\n    if (!response.ok) {\r\n      if (retriesRemaining && this.shouldRetry(response)) {\r\n        const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\r\n        debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders);\r\n        return this.retryRequest(options, retriesRemaining, responseHeaders);\r\n      }\r\n\r\n      const errText = await response.text().catch((e) => castToError(e).message);\r\n      const errJSON = safeJSON(errText);\r\n      const errMessage = errJSON ? undefined : errText;\r\n      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;\r\n\r\n      debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);\r\n\r\n      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);\r\n      throw err;\r\n    }\r\n\r\n    return { response, options, controller };\r\n  }\r\n\r\n  requestAPIList<Item = unknown, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(\r\n    Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass,\r\n    options: FinalRequestOptions,\r\n  ): PagePromise<PageClass, Item> {\r\n    const request = this.makeRequest(options, null);\r\n    return new PagePromise<PageClass, Item>(this, request, Page);\r\n  }\r\n\r\n  buildURL<Req>(path: string, query: Req | null | undefined): string {\r\n    const url =\r\n      isAbsoluteURL(path) ?\r\n        new URL(path)\r\n      : new URL(this.baseURL + (this.baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));\r\n\r\n    const defaultQuery = this.defaultQuery();\r\n    if (!isEmptyObj(defaultQuery)) {\r\n      query = { ...defaultQuery, ...query } as Req;\r\n    }\r\n\r\n    if (typeof query === 'object' && query && !Array.isArray(query)) {\r\n      url.search = this.stringifyQuery(query as Record<string, unknown>);\r\n    }\r\n\r\n    return url.toString();\r\n  }\r\n\r\n  protected stringifyQuery(query: Record<string, unknown>): string {\r\n    return Object.entries(query)\r\n      .filter(([_, value]) => typeof value !== 'undefined')\r\n      .map(([key, value]) => {\r\n        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\r\n          return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\r\n        }\r\n        if (value === null) {\r\n          return `${encodeURIComponent(key)}=`;\r\n        }\r\n        throw new GroqError(\r\n          `Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`,\r\n        );\r\n      })\r\n      .join('&');\r\n  }\r\n\r\n  async fetchWithTimeout(\r\n    url: RequestInfo,\r\n    init: RequestInit | undefined,\r\n    ms: number,\r\n    controller: AbortController,\r\n  ): Promise<Response> {\r\n    const { signal, ...options } = init || {};\r\n    if (signal) signal.addEventListener('abort', () => controller.abort());\r\n\r\n    const timeout = setTimeout(() => controller.abort(), ms);\r\n\r\n    const fetchOptions = {\r\n      signal: controller.signal as any,\r\n      ...options,\r\n    };\r\n    if (fetchOptions.method) {\r\n      // Custom methods like 'patch' need to be uppercased\r\n      // See https://github.com/nodejs/undici/issues/2294\r\n      fetchOptions.method = fetchOptions.method.toUpperCase();\r\n    }\r\n\r\n    return (\r\n      // use undefined this binding; fetch errors if bound to something else in browser/cloudflare\r\n      this.fetch.call(undefined, url, fetchOptions).finally(() => {\r\n        clearTimeout(timeout);\r\n      })\r\n    );\r\n  }\r\n\r\n  private shouldRetry(response: Response): boolean {\r\n    // Note this is not a standard header.\r\n    const shouldRetryHeader = response.headers.get('x-should-retry');\r\n\r\n    // If the server explicitly says whether or not to retry, obey.\r\n    if (shouldRetryHeader === 'true') return true;\r\n    if (shouldRetryHeader === 'false') return false;\r\n\r\n    // Retry on request timeouts.\r\n    if (response.status === 408) return true;\r\n\r\n    // Retry on lock timeouts.\r\n    if (response.status === 409) return true;\r\n\r\n    // Retry on rate limits.\r\n    if (response.status === 429) return true;\r\n\r\n    // Retry internal errors.\r\n    if (response.status >= 500) return true;\r\n\r\n    return false;\r\n  }\r\n\r\n  private async retryRequest(\r\n    options: FinalRequestOptions,\r\n    retriesRemaining: number,\r\n    responseHeaders?: Headers | undefined,\r\n  ): Promise<APIResponseProps> {\r\n    let timeoutMillis: number | undefined;\r\n\r\n    // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.\r\n    const retryAfterMillisHeader = responseHeaders?.['retry-after-ms'];\r\n    if (retryAfterMillisHeader) {\r\n      const timeoutMs = parseFloat(retryAfterMillisHeader);\r\n      if (!Number.isNaN(timeoutMs)) {\r\n        timeoutMillis = timeoutMs;\r\n      }\r\n    }\r\n\r\n    // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\r\n    const retryAfterHeader = responseHeaders?.['retry-after'];\r\n    if (retryAfterHeader && !timeoutMillis) {\r\n      const timeoutSeconds = parseFloat(retryAfterHeader);\r\n      if (!Number.isNaN(timeoutSeconds)) {\r\n        timeoutMillis = timeoutSeconds * 1000;\r\n      } else {\r\n        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();\r\n      }\r\n    }\r\n\r\n    // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\r\n    // just do what it says, but otherwise calculate a default\r\n    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {\r\n      const maxRetries = options.maxRetries ?? this.maxRetries;\r\n      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);\r\n    }\r\n    await sleep(timeoutMillis);\r\n\r\n    return this.makeRequest(options, retriesRemaining - 1);\r\n  }\r\n\r\n  private calculateDefaultRetryTimeoutMillis(retriesRemaining: number, maxRetries: number): number {\r\n    const initialRetryDelay = 0.5;\r\n    const maxRetryDelay = 8.0;\r\n\r\n    const numRetries = maxRetries - retriesRemaining;\r\n\r\n    // Apply exponential backoff, but not more than the max.\r\n    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);\r\n\r\n    // Apply some jitter, take up to at most 25 percent of the retry time.\r\n    const jitter = 1 - Math.random() * 0.25;\r\n\r\n    return sleepSeconds * jitter * 1000;\r\n  }\r\n\r\n  private getUserAgent(): string {\r\n    return `${this.constructor.name}/JS ${VERSION}`;\r\n  }\r\n}\r\n\r\nexport type PageInfo = { url: URL } | { params: Record<string, unknown> | null };\r\n\r\nexport abstract class AbstractPage<Item> implements AsyncIterable<Item> {\r\n  #client: APIClient;\r\n  protected options: FinalRequestOptions;\r\n\r\n  protected response: Response;\r\n  protected body: unknown;\r\n\r\n  constructor(client: APIClient, response: Response, body: unknown, options: FinalRequestOptions) {\r\n    this.#client = client;\r\n    this.options = options;\r\n    this.response = response;\r\n    this.body = body;\r\n  }\r\n\r\n  /**\r\n   * @deprecated Use nextPageInfo instead\r\n   */\r\n  abstract nextPageParams(): Partial<Record<string, unknown>> | null;\r\n  abstract nextPageInfo(): PageInfo | null;\r\n\r\n  abstract getPaginatedItems(): Item[];\r\n\r\n  hasNextPage(): boolean {\r\n    const items = this.getPaginatedItems();\r\n    if (!items.length) return false;\r\n    return this.nextPageInfo() != null;\r\n  }\r\n\r\n  async getNextPage(): Promise<this> {\r\n    const nextInfo = this.nextPageInfo();\r\n    if (!nextInfo) {\r\n      throw new GroqError(\r\n        'No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.',\r\n      );\r\n    }\r\n    const nextOptions = { ...this.options };\r\n    if ('params' in nextInfo && typeof nextOptions.query === 'object') {\r\n      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };\r\n    } else if ('url' in nextInfo) {\r\n      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];\r\n      for (const [key, value] of params) {\r\n        nextInfo.url.searchParams.set(key, value as any);\r\n      }\r\n      nextOptions.query = undefined;\r\n      nextOptions.path = nextInfo.url.toString();\r\n    }\r\n    return await this.#client.requestAPIList(this.constructor as any, nextOptions);\r\n  }\r\n\r\n  async *iterPages(): AsyncGenerator<this> {\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    let page: this = this;\r\n    yield page;\r\n    while (page.hasNextPage()) {\r\n      page = await page.getNextPage();\r\n      yield page;\r\n    }\r\n  }\r\n\r\n  async *[Symbol.asyncIterator](): AsyncGenerator<Item> {\r\n    for await (const page of this.iterPages()) {\r\n      for (const item of page.getPaginatedItems()) {\r\n        yield item;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\r\n *\r\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\r\n *\r\n *    for await (const item of client.items.list()) {\r\n *      console.log(item)\r\n *    }\r\n */\r\nexport class PagePromise<\r\n    PageClass extends AbstractPage<Item>,\r\n    Item = ReturnType<PageClass['getPaginatedItems']>[number],\r\n  >\r\n  extends APIPromise<PageClass>\r\n  implements AsyncIterable<Item>\r\n{\r\n  constructor(\r\n    client: APIClient,\r\n    request: Promise<APIResponseProps>,\r\n    Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass,\r\n  ) {\r\n    super(\r\n      request,\r\n      async (props) => new Page(client, props.response, await defaultParseResponse(props), props.options),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Allow auto-paginating iteration on an unawaited list call, eg:\r\n   *\r\n   *    for await (const item of client.items.list()) {\r\n   *      console.log(item)\r\n   *    }\r\n   */\r\n  async *[Symbol.asyncIterator](): AsyncGenerator<Item> {\r\n    const page = await this;\r\n    for await (const item of page) {\r\n      yield item;\r\n    }\r\n  }\r\n}\r\n\r\nexport const createResponseHeaders = (\r\n  headers: Awaited<ReturnType<Fetch>>['headers'],\r\n): Record<string, string> => {\r\n  return new Proxy(\r\n    Object.fromEntries(\r\n      // @ts-ignore\r\n      headers.entries(),\r\n    ),\r\n    {\r\n      get(target, name) {\r\n        const key = name.toString();\r\n        return target[key.toLowerCase()] || target[key];\r\n      },\r\n    },\r\n  );\r\n};\r\n\r\ntype HTTPMethod = 'get' | 'post' | 'put' | 'patch' | 'delete';\r\n\r\nexport type RequestClient = { fetch: Fetch };\r\nexport type Headers = Record<string, string | null | undefined>;\r\nexport type DefaultQuery = Record<string, string | undefined>;\r\nexport type KeysEnum<T> = { [P in keyof Required<T>]: true };\r\n\r\nexport type RequestOptions<\r\n  Req = unknown | Record<string, unknown> | Readable | BlobLike | ArrayBufferView | ArrayBuffer,\r\n> = {\r\n  method?: HTTPMethod;\r\n  path?: string;\r\n  query?: Req | undefined;\r\n  body?: Req | null | undefined;\r\n  headers?: Headers | undefined;\r\n\r\n  maxRetries?: number;\r\n  stream?: boolean | undefined;\r\n  timeout?: number;\r\n  httpAgent?: Agent;\r\n  signal?: AbortSignal | undefined | null;\r\n  idempotencyKey?: string;\r\n\r\n  __binaryRequest?: boolean | undefined;\r\n  __binaryResponse?: boolean | undefined;\r\n  __streamClass?: typeof Stream;\r\n};\r\n\r\n// This is required so that we can determine if a given object matches the RequestOptions\r\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\r\n// compiler such that any missing / extraneous keys will cause an error.\r\nconst requestOptionsKeys: KeysEnum<RequestOptions> = {\r\n  method: true,\r\n  path: true,\r\n  query: true,\r\n  body: true,\r\n  headers: true,\r\n\r\n  maxRetries: true,\r\n  stream: true,\r\n  timeout: true,\r\n  httpAgent: true,\r\n  signal: true,\r\n  idempotencyKey: true,\r\n\r\n  __binaryRequest: true,\r\n  __binaryResponse: true,\r\n  __streamClass: true,\r\n};\r\n\r\nexport const isRequestOptions = (obj: unknown): obj is RequestOptions => {\r\n  return (\r\n    typeof obj === 'object' &&\r\n    obj !== null &&\r\n    !isEmptyObj(obj) &&\r\n    Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k))\r\n  );\r\n};\r\n\r\nexport type FinalRequestOptions<Req = unknown | Record<string, unknown> | Readable | DataView> =\r\n  RequestOptions<Req> & {\r\n    method: HTTPMethod;\r\n    path: string;\r\n  };\r\n\r\ndeclare const Deno: any;\r\ndeclare const EdgeRuntime: any;\r\ntype Arch = 'x32' | 'x64' | 'arm' | 'arm64' | `other:${string}` | 'unknown';\r\ntype PlatformName =\r\n  | 'MacOS'\r\n  | 'Linux'\r\n  | 'Windows'\r\n  | 'FreeBSD'\r\n  | 'OpenBSD'\r\n  | 'iOS'\r\n  | 'Android'\r\n  | `Other:${string}`\r\n  | 'Unknown';\r\ntype Browser = 'ie' | 'edge' | 'chrome' | 'firefox' | 'safari';\r\ntype PlatformProperties = {\r\n  'X-Stainless-Lang': 'js';\r\n  'X-Stainless-Package-Version': string;\r\n  'X-Stainless-OS': PlatformName;\r\n  'X-Stainless-Arch': Arch;\r\n  'X-Stainless-Runtime': 'node' | 'deno' | 'edge' | `browser:${Browser}` | 'unknown';\r\n  'X-Stainless-Runtime-Version': string;\r\n};\r\nconst getPlatformProperties = (): PlatformProperties => {\r\n  if (typeof Deno !== 'undefined' && Deno.build != null) {\r\n    return {\r\n      'X-Stainless-Lang': 'js',\r\n      'X-Stainless-Package-Version': VERSION,\r\n      'X-Stainless-OS': normalizePlatform(Deno.build.os),\r\n      'X-Stainless-Arch': normalizeArch(Deno.build.arch),\r\n      'X-Stainless-Runtime': 'deno',\r\n      'X-Stainless-Runtime-Version':\r\n        typeof Deno.version === 'string' ? Deno.version : Deno.version?.deno ?? 'unknown',\r\n    };\r\n  }\r\n  if (typeof EdgeRuntime !== 'undefined') {\r\n    return {\r\n      'X-Stainless-Lang': 'js',\r\n      'X-Stainless-Package-Version': VERSION,\r\n      'X-Stainless-OS': 'Unknown',\r\n      'X-Stainless-Arch': `other:${EdgeRuntime}`,\r\n      'X-Stainless-Runtime': 'edge',\r\n      'X-Stainless-Runtime-Version': process.version,\r\n    };\r\n  }\r\n  // Check if Node.js\r\n  if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]') {\r\n    return {\r\n      'X-Stainless-Lang': 'js',\r\n      'X-Stainless-Package-Version': VERSION,\r\n      'X-Stainless-OS': normalizePlatform(process.platform),\r\n      'X-Stainless-Arch': normalizeArch(process.arch),\r\n      'X-Stainless-Runtime': 'node',\r\n      'X-Stainless-Runtime-Version': process.version,\r\n    };\r\n  }\r\n\r\n  const browserInfo = getBrowserInfo();\r\n  if (browserInfo) {\r\n    return {\r\n      'X-Stainless-Lang': 'js',\r\n      'X-Stainless-Package-Version': VERSION,\r\n      'X-Stainless-OS': 'Unknown',\r\n      'X-Stainless-Arch': 'unknown',\r\n      'X-Stainless-Runtime': `browser:${browserInfo.browser}`,\r\n      'X-Stainless-Runtime-Version': browserInfo.version,\r\n    };\r\n  }\r\n\r\n  // TODO add support for Cloudflare workers, etc.\r\n  return {\r\n    'X-Stainless-Lang': 'js',\r\n    'X-Stainless-Package-Version': VERSION,\r\n    'X-Stainless-OS': 'Unknown',\r\n    'X-Stainless-Arch': 'unknown',\r\n    'X-Stainless-Runtime': 'unknown',\r\n    'X-Stainless-Runtime-Version': 'unknown',\r\n  };\r\n};\r\n\r\ntype BrowserInfo = {\r\n  browser: Browser;\r\n  version: string;\r\n};\r\n\r\ndeclare const navigator: { userAgent: string } | undefined;\r\n\r\n// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\r\nfunction getBrowserInfo(): BrowserInfo | null {\r\n  if (typeof navigator === 'undefined' || !navigator) {\r\n    return null;\r\n  }\r\n\r\n  // NOTE: The order matters here!\r\n  const browserPatterns = [\r\n    { key: 'edge' as const, pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\r\n    { key: 'ie' as const, pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\r\n    { key: 'ie' as const, pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\r\n    { key: 'chrome' as const, pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\r\n    { key: 'firefox' as const, pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\r\n    { key: 'safari' as const, pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/ },\r\n  ];\r\n\r\n  // Find the FIRST matching browser\r\n  for (const { key, pattern } of browserPatterns) {\r\n    const match = pattern.exec(navigator.userAgent);\r\n    if (match) {\r\n      const major = match[1] || 0;\r\n      const minor = match[2] || 0;\r\n      const patch = match[3] || 0;\r\n\r\n      return { browser: key, version: `${major}.${minor}.${patch}` };\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nconst normalizeArch = (arch: string): Arch => {\r\n  // Node docs:\r\n  // - https://nodejs.org/api/process.html#processarch\r\n  // Deno docs:\r\n  // - https://doc.deno.land/deno/stable/~/Deno.build\r\n  if (arch === 'x32') return 'x32';\r\n  if (arch === 'x86_64' || arch === 'x64') return 'x64';\r\n  if (arch === 'arm') return 'arm';\r\n  if (arch === 'aarch64' || arch === 'arm64') return 'arm64';\r\n  if (arch) return `other:${arch}`;\r\n  return 'unknown';\r\n};\r\n\r\nconst normalizePlatform = (platform: string): PlatformName => {\r\n  // Node platforms:\r\n  // - https://nodejs.org/api/process.html#processplatform\r\n  // Deno platforms:\r\n  // - https://doc.deno.land/deno/stable/~/Deno.build\r\n  // - https://github.com/denoland/deno/issues/14799\r\n\r\n  platform = platform.toLowerCase();\r\n\r\n  // NOTE: this iOS check is untested and may not work\r\n  // Node does not work natively on IOS, there is a fork at\r\n  // https://github.com/nodejs-mobile/nodejs-mobile\r\n  // however it is unknown at the time of writing how to detect if it is running\r\n  if (platform.includes('ios')) return 'iOS';\r\n  if (platform === 'android') return 'Android';\r\n  if (platform === 'darwin') return 'MacOS';\r\n  if (platform === 'win32') return 'Windows';\r\n  if (platform === 'freebsd') return 'FreeBSD';\r\n  if (platform === 'openbsd') return 'OpenBSD';\r\n  if (platform === 'linux') return 'Linux';\r\n  if (platform) return `Other:${platform}`;\r\n  return 'Unknown';\r\n};\r\n\r\nlet _platformHeaders: PlatformProperties;\r\nconst getPlatformHeaders = () => {\r\n  return (_platformHeaders ??= getPlatformProperties());\r\n};\r\n\r\nexport const safeJSON = (text: string) => {\r\n  try {\r\n    return JSON.parse(text);\r\n  } catch (err) {\r\n    return undefined;\r\n  }\r\n};\r\n\r\n// https://url.spec.whatwg.org/#url-scheme-string\r\nconst startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;\r\nconst isAbsoluteURL = (url: string): boolean => {\r\n  return startsWithSchemeRegexp.test(url);\r\n};\r\n\r\nexport const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\r\n\r\nconst validatePositiveInteger = (name: string, n: unknown): number => {\r\n  if (typeof n !== 'number' || !Number.isInteger(n)) {\r\n    throw new GroqError(`${name} must be an integer`);\r\n  }\r\n  if (n < 0) {\r\n    throw new GroqError(`${name} must be a positive integer`);\r\n  }\r\n  return n;\r\n};\r\n\r\nexport const castToError = (err: any): Error => {\r\n  if (err instanceof Error) return err;\r\n  if (typeof err === 'object' && err !== null) {\r\n    try {\r\n      return new Error(JSON.stringify(err));\r\n    } catch {}\r\n  }\r\n  return new Error(err);\r\n};\r\n\r\nexport const ensurePresent = <T>(value: T | null | undefined): T => {\r\n  if (value == null) throw new GroqError(`Expected a value to be given but received ${value} instead.`);\r\n  return value;\r\n};\r\n\r\n/**\r\n * Read an environment variable.\r\n *\r\n * Trims beginning and trailing whitespace.\r\n *\r\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\r\n */\r\nexport const readEnv = (env: string): string | undefined => {\r\n  if (typeof process !== 'undefined') {\r\n    return process.env?.[env]?.trim() ?? undefined;\r\n  }\r\n  if (typeof Deno !== 'undefined') {\r\n    return Deno.env?.get?.(env)?.trim();\r\n  }\r\n  return undefined;\r\n};\r\n\r\nexport const coerceInteger = (value: unknown): number => {\r\n  if (typeof value === 'number') return Math.round(value);\r\n  if (typeof value === 'string') return parseInt(value, 10);\r\n\r\n  throw new GroqError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\r\n};\r\n\r\nexport const coerceFloat = (value: unknown): number => {\r\n  if (typeof value === 'number') return value;\r\n  if (typeof value === 'string') return parseFloat(value);\r\n\r\n  throw new GroqError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\r\n};\r\n\r\nexport const coerceBoolean = (value: unknown): boolean => {\r\n  if (typeof value === 'boolean') return value;\r\n  if (typeof value === 'string') return value === 'true';\r\n  return Boolean(value);\r\n};\r\n\r\nexport const maybeCoerceInteger = (value: unknown): number | undefined => {\r\n  if (value === undefined) {\r\n    return undefined;\r\n  }\r\n  return coerceInteger(value);\r\n};\r\n\r\nexport const maybeCoerceFloat = (value: unknown): number | undefined => {\r\n  if (value === undefined) {\r\n    return undefined;\r\n  }\r\n  return coerceFloat(value);\r\n};\r\n\r\nexport const maybeCoerceBoolean = (value: unknown): boolean | undefined => {\r\n  if (value === undefined) {\r\n    return undefined;\r\n  }\r\n  return coerceBoolean(value);\r\n};\r\n\r\n// https://stackoverflow.com/a/34491287\r\nexport function isEmptyObj(obj: Object | null | undefined): boolean {\r\n  if (!obj) return true;\r\n  for (const _k in obj) return false;\r\n  return true;\r\n}\r\n\r\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\r\nexport function hasOwn(obj: Object, key: string): boolean {\r\n  return Object.prototype.hasOwnProperty.call(obj, key);\r\n}\r\n\r\n/**\r\n * Copies headers from \"newHeaders\" onto \"targetHeaders\",\r\n * using lower-case for all properties,\r\n * ignoring any keys with undefined values,\r\n * and deleting any keys with null values.\r\n */\r\nfunction applyHeadersMut(targetHeaders: Headers, newHeaders: Headers): void {\r\n  for (const k in newHeaders) {\r\n    if (!hasOwn(newHeaders, k)) continue;\r\n    const lowerKey = k.toLowerCase();\r\n    if (!lowerKey) continue;\r\n\r\n    const val = newHeaders[k];\r\n\r\n    if (val === null) {\r\n      delete targetHeaders[lowerKey];\r\n    } else if (val !== undefined) {\r\n      targetHeaders[lowerKey] = val;\r\n    }\r\n  }\r\n}\r\n\r\nexport function debug(action: string, ...args: any[]) {\r\n  if (typeof process !== 'undefined' && process?.env?.['DEBUG'] === 'true') {\r\n    console.log(`Groq:DEBUG:${action}`, ...args);\r\n  }\r\n}\r\n\r\n/**\r\n * https://stackoverflow.com/a/2117523\r\n */\r\nconst uuid4 = () => {\r\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n    const r = (Math.random() * 16) | 0;\r\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\r\n    return v.toString(16);\r\n  });\r\n};\r\n\r\nexport const isRunningInBrowser = () => {\r\n  return (\r\n    // @ts-ignore\r\n    typeof window !== 'undefined' &&\r\n    // @ts-ignore\r\n    typeof window.document !== 'undefined' &&\r\n    // @ts-ignore\r\n    typeof navigator !== 'undefined'\r\n  );\r\n};\r\n\r\nexport interface HeadersProtocol {\r\n  get: (header: string) => string | null | undefined;\r\n}\r\nexport type HeadersLike = Record<string, string | string[] | undefined> | HeadersProtocol;\r\n\r\nexport const isHeadersProtocol = (headers: any): headers is HeadersProtocol => {\r\n  return typeof headers?.get === 'function';\r\n};\r\n\r\nexport const getRequiredHeader = (headers: HeadersLike | Headers, header: string): string => {\r\n  const foundHeader = getHeader(headers, header);\r\n  if (foundHeader === undefined) {\r\n    throw new Error(`Could not find ${header} header`);\r\n  }\r\n  return foundHeader;\r\n};\r\n\r\nexport const getHeader = (headers: HeadersLike | Headers, header: string): string | undefined => {\r\n  const lowerCasedHeader = header.toLowerCase();\r\n  if (isHeadersProtocol(headers)) {\r\n    // to deal with the case where the header looks like Stainless-Event-Id\r\n    const intercapsHeader =\r\n      header[0]?.toUpperCase() +\r\n      header.substring(1).replace(/([^\\w])(\\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());\r\n    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {\r\n      const value = headers.get(key);\r\n      if (value) {\r\n        return value;\r\n      }\r\n    }\r\n  }\r\n\r\n  for (const [key, value] of Object.entries(headers)) {\r\n    if (key.toLowerCase() === lowerCasedHeader) {\r\n      if (Array.isArray(value)) {\r\n        if (value.length <= 1) return value[0];\r\n        console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);\r\n        return value[0];\r\n      }\r\n      return value;\r\n    }\r\n  }\r\n\r\n  return undefined;\r\n};\r\n\r\n/**\r\n * Encodes a string to Base64 format.\r\n */\r\nexport const toBase64 = (str: string | null | undefined): string => {\r\n  if (!str) return '';\r\n  if (typeof Buffer !== 'undefined') {\r\n    return Buffer.from(str).toString('base64');\r\n  }\r\n\r\n  if (typeof btoa !== 'undefined') {\r\n    return btoa(str);\r\n  }\r\n\r\n  throw new GroqError('Cannot generate b64 string; Expected `Buffer` or `btoa` to be defined');\r\n};\r\n\r\nexport function isObj(obj: unknown): obj is Record<string, unknown> {\r\n  return obj != null && typeof obj === 'object' && !Array.isArray(obj);\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport type { Groq } from './index';\r\n\r\nexport class APIResource {\r\n  protected _client: Groq;\r\n\r\n  constructor(client: Groq) {\r\n    this._client = client;\r\n  }\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from '../../resource';\r\nimport * as Core from '../../core';\r\n\r\nexport class Transcriptions extends APIResource {\r\n  /**\r\n   * Transcribes audio into the input language.\r\n   */\r\n  create(body: TranscriptionCreateParams, options?: Core.RequestOptions): Core.APIPromise<Transcription> {\r\n    return this._client.post(\r\n      '/openai/v1/audio/transcriptions',\r\n      Core.multipartFormRequestOptions({ body, ...options }),\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Represents a transcription response returned by model, based on the provided\r\n * input.\r\n */\r\nexport interface Transcription {\r\n  /**\r\n   * The transcribed text.\r\n   */\r\n  text: string;\r\n}\r\n\r\nexport interface TranscriptionCreateParams {\r\n  /**\r\n   * The audio file object (not file name) to transcribe, in one of these formats:\r\n   * flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.\r\n   */\r\n  file: Core.Uploadable;\r\n\r\n  /**\r\n   * ID of the model to use. Only `whisper-large-v3` is currently available.\r\n   */\r\n  model: (string & {}) | 'whisper-large-v3';\r\n\r\n  /**\r\n   * The language of the input audio. Supplying the input language in\r\n   * [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will\r\n   * improve accuracy and latency.\r\n   */\r\n  language?:\r\n    | (string & {})\r\n    | 'en'\r\n    | 'zh'\r\n    | 'de'\r\n    | 'es'\r\n    | 'ru'\r\n    | 'ko'\r\n    | 'fr'\r\n    | 'ja'\r\n    | 'pt'\r\n    | 'tr'\r\n    | 'pl'\r\n    | 'ca'\r\n    | 'nl'\r\n    | 'ar'\r\n    | 'sv'\r\n    | 'it'\r\n    | 'id'\r\n    | 'hi'\r\n    | 'fi'\r\n    | 'vi'\r\n    | 'he'\r\n    | 'uk'\r\n    | 'el'\r\n    | 'ms'\r\n    | 'cs'\r\n    | 'ro'\r\n    | 'da'\r\n    | 'hu'\r\n    | 'ta'\r\n    | 'no'\r\n    | 'th'\r\n    | 'ur'\r\n    | 'hr'\r\n    | 'bg'\r\n    | 'lt'\r\n    | 'la'\r\n    | 'mi'\r\n    | 'ml'\r\n    | 'cy'\r\n    | 'sk'\r\n    | 'te'\r\n    | 'fa'\r\n    | 'lv'\r\n    | 'bn'\r\n    | 'sr'\r\n    | 'az'\r\n    | 'sl'\r\n    | 'kn'\r\n    | 'et'\r\n    | 'mk'\r\n    | 'br'\r\n    | 'eu'\r\n    | 'is'\r\n    | 'hy'\r\n    | 'ne'\r\n    | 'mn'\r\n    | 'bs'\r\n    | 'kk'\r\n    | 'sq'\r\n    | 'sw'\r\n    | 'gl'\r\n    | 'mr'\r\n    | 'pa'\r\n    | 'si'\r\n    | 'km'\r\n    | 'sn'\r\n    | 'yo'\r\n    | 'so'\r\n    | 'af'\r\n    | 'oc'\r\n    | 'ka'\r\n    | 'be'\r\n    | 'tg'\r\n    | 'sd'\r\n    | 'gu'\r\n    | 'am'\r\n    | 'yi'\r\n    | 'lo'\r\n    | 'uz'\r\n    | 'fo'\r\n    | 'ht'\r\n    | 'ps'\r\n    | 'tk'\r\n    | 'nn'\r\n    | 'mt'\r\n    | 'sa'\r\n    | 'lb'\r\n    | 'my'\r\n    | 'bo'\r\n    | 'tl'\r\n    | 'mg'\r\n    | 'as'\r\n    | 'tt'\r\n    | 'haw'\r\n    | 'ln'\r\n    | 'ha'\r\n    | 'ba'\r\n    | 'jv'\r\n    | 'su'\r\n    | 'yue';\r\n\r\n  /**\r\n   * An optional text to guide the model's style or continue a previous audio\r\n   * segment. The [prompt](/docs/speech-text) should match the audio language.\r\n   */\r\n  prompt?: string;\r\n\r\n  /**\r\n   * The format of the transcript output, in one of these options: `json`, `text`, or\r\n   * `verbose_json`.\r\n   */\r\n  response_format?: 'json' | 'text' | 'verbose_json';\r\n\r\n  /**\r\n   * The sampling temperature, between 0 and 1. Higher values like 0.8 will make the\r\n   * output more random, while lower values like 0.2 will make it more focused and\r\n   * deterministic. If set to 0, the model will use\r\n   * [log probability](https://en.wikipedia.org/wiki/Log_probability) to\r\n   * automatically increase the temperature until certain thresholds are hit.\r\n   */\r\n  temperature?: number;\r\n\r\n  /**\r\n   * The timestamp granularities to populate for this transcription.\r\n   * `response_format` must be set `verbose_json` to use timestamp granularities.\r\n   * Either or both of these options are supported: `word`, or `segment`. Note: There\r\n   * is no additional latency for segment timestamps, but generating word timestamps\r\n   * incurs additional latency.\r\n   */\r\n  timestamp_granularities?: Array<'word' | 'segment'>;\r\n}\r\n\r\nexport declare namespace Transcriptions {\r\n  export { type Transcription as Transcription, type TranscriptionCreateParams as TranscriptionCreateParams };\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from '../../resource';\r\nimport * as Core from '../../core';\r\n\r\nexport class Translations extends APIResource {\r\n  /**\r\n   * Translates audio into English.\r\n   */\r\n  create(body: TranslationCreateParams, options?: Core.RequestOptions): Core.APIPromise<Translation> {\r\n    return this._client.post(\r\n      '/openai/v1/audio/translations',\r\n      Core.multipartFormRequestOptions({ body, ...options }),\r\n    );\r\n  }\r\n}\r\n\r\nexport interface Translation {\r\n  text: string;\r\n}\r\n\r\nexport interface TranslationCreateParams {\r\n  /**\r\n   * The audio file object (not file name) translate, in one of these formats: flac,\r\n   * mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.\r\n   */\r\n  file: Core.Uploadable;\r\n\r\n  /**\r\n   * ID of the model to use. Only `whisper-large-v3` is currently available.\r\n   */\r\n  model: (string & {}) | 'whisper-large-v3';\r\n\r\n  /**\r\n   * An optional text to guide the model's style or continue a previous audio\r\n   * segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in\r\n   * English.\r\n   */\r\n  prompt?: string;\r\n\r\n  /**\r\n   * The format of the transcript output, in one of these options: `json`, `text`, or\r\n   * `verbose_json`.\r\n   */\r\n  response_format?: 'json' | 'text' | 'verbose_json';\r\n\r\n  /**\r\n   * The sampling temperature, between 0 and 1. Higher values like 0.8 will make the\r\n   * output more random, while lower values like 0.2 will make it more focused and\r\n   * deterministic. If set to 0, the model will use\r\n   * [log probability](https://en.wikipedia.org/wiki/Log_probability) to\r\n   * automatically increase the temperature until certain thresholds are hit.\r\n   */\r\n  temperature?: number;\r\n}\r\n\r\nexport declare namespace Translations {\r\n  export { type Translation as Translation, type TranslationCreateParams as TranslationCreateParams };\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from '../../resource';\r\nimport * as TranscriptionsAPI from './transcriptions';\r\nimport { Transcription, TranscriptionCreateParams, Transcriptions } from './transcriptions';\r\nimport * as TranslationsAPI from './translations';\r\nimport { Translation, TranslationCreateParams, Translations } from './translations';\r\n\r\nexport class Audio extends APIResource {\r\n  transcriptions: TranscriptionsAPI.Transcriptions = new TranscriptionsAPI.Transcriptions(this._client);\r\n  translations: TranslationsAPI.Translations = new TranslationsAPI.Translations(this._client);\r\n}\r\n\r\nAudio.Transcriptions = Transcriptions;\r\nAudio.Translations = Translations;\r\n\r\nexport declare namespace Audio {\r\n  export {\r\n    Transcriptions as Transcriptions,\r\n    type Transcription as Transcription,\r\n    type TranscriptionCreateParams as TranscriptionCreateParams,\r\n  };\r\n\r\n  export {\r\n    Translations as Translations,\r\n    type Translation as Translation,\r\n    type TranslationCreateParams as TranslationCreateParams,\r\n  };\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from '../resource';\r\nimport * as Core from '../core';\r\n\r\nexport class Batches extends APIResource {\r\n  /**\r\n   * Creates and executes a batch from an uploaded file of requests\r\n   */\r\n  create(body: BatchCreateParams, options?: Core.RequestOptions): Core.APIPromise<BatchCreateResponse> {\r\n    return this._client.post('/openai/v1/batches', { body, ...options });\r\n  }\r\n\r\n  /**\r\n   * Retrieves a batch.\r\n   */\r\n  retrieve(batchId: string, options?: Core.RequestOptions): Core.APIPromise<BatchRetrieveResponse> {\r\n    return this._client.get(`/openai/v1/batches/${batchId}`, options);\r\n  }\r\n\r\n  /**\r\n   * List your organization's batches.\r\n   */\r\n  list(options?: Core.RequestOptions): Core.APIPromise<BatchListResponse> {\r\n    return this._client.get('/openai/v1/batches', options);\r\n  }\r\n}\r\n\r\nexport interface BatchCreateResponse {\r\n  id: string;\r\n\r\n  /**\r\n   * The time frame within which the batch should be processed.\r\n   */\r\n  completion_window: string;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the batch was created.\r\n   */\r\n  created_at: number;\r\n\r\n  /**\r\n   * The API endpoint used by the batch.\r\n   */\r\n  endpoint: string;\r\n\r\n  /**\r\n   * The ID of the input file for the batch.\r\n   */\r\n  input_file_id: string;\r\n\r\n  /**\r\n   * The object type, which is always `batch`.\r\n   */\r\n  object: 'batch';\r\n\r\n  /**\r\n   * The current status of the batch.\r\n   */\r\n  status:\r\n    | 'validating'\r\n    | 'failed'\r\n    | 'in_progress'\r\n    | 'finalizing'\r\n    | 'completed'\r\n    | 'expired'\r\n    | 'cancelling'\r\n    | 'cancelled';\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the batch was cancelled.\r\n   */\r\n  cancelled_at?: number;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the batch started cancelling.\r\n   */\r\n  cancelling_at?: number;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the batch was completed.\r\n   */\r\n  completed_at?: number;\r\n\r\n  /**\r\n   * The ID of the file containing the outputs of requests with errors.\r\n   */\r\n  error_file_id?: string;\r\n\r\n  errors?: BatchCreateResponse.Errors;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the batch expired.\r\n   */\r\n  expired_at?: number;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the batch will expire.\r\n   */\r\n  expires_at?: number;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the batch failed.\r\n   */\r\n  failed_at?: number;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the batch started finalizing.\r\n   */\r\n  finalizing_at?: number;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the batch started processing.\r\n   */\r\n  in_progress_at?: number;\r\n\r\n  /**\r\n   * Set of key-value pairs that can be attached to an object. This can be useful for\r\n   * storing additional information about the object in a structured format.\r\n   */\r\n  metadata?: unknown | null;\r\n\r\n  /**\r\n   * The ID of the file containing the outputs of successfully executed requests.\r\n   */\r\n  output_file_id?: string;\r\n\r\n  /**\r\n   * The request counts for different statuses within the batch.\r\n   */\r\n  request_counts?: BatchCreateResponse.RequestCounts;\r\n}\r\n\r\nexport namespace BatchCreateResponse {\r\n  export interface Errors {\r\n    data?: Array<Errors.Data>;\r\n\r\n    /**\r\n     * The object type, which is always `list`.\r\n     */\r\n    object?: string;\r\n  }\r\n\r\n  export namespace Errors {\r\n    export interface Data {\r\n      /**\r\n       * An error code identifying the error type.\r\n       */\r\n      code?: string;\r\n\r\n      /**\r\n       * The line number of the input file where the error occurred, if applicable.\r\n       */\r\n      line?: number | null;\r\n\r\n      /**\r\n       * A human-readable message providing more details about the error.\r\n       */\r\n      message?: string;\r\n\r\n      /**\r\n       * The name of the parameter that caused the error, if applicable.\r\n       */\r\n      param?: string | null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The request counts for different statuses within the batch.\r\n   */\r\n  export interface RequestCounts {\r\n    /**\r\n     * Number of requests that have been completed successfully.\r\n     */\r\n    completed: number;\r\n\r\n    /**\r\n     * Number of requests that have failed.\r\n     */\r\n    failed: number;\r\n\r\n    /**\r\n     * Total number of requests in the batch.\r\n     */\r\n    total: number;\r\n  }\r\n}\r\n\r\nexport interface BatchRetrieveResponse {\r\n  id: string;\r\n\r\n  /**\r\n   * The time frame within which the batch should be processed.\r\n   */\r\n  completion_window: string;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the batch was created.\r\n   */\r\n  created_at: number;\r\n\r\n  /**\r\n   * The API endpoint used by the batch.\r\n   */\r\n  endpoint: string;\r\n\r\n  /**\r\n   * The ID of the input file for the batch.\r\n   */\r\n  input_file_id: string;\r\n\r\n  /**\r\n   * The object type, which is always `batch`.\r\n   */\r\n  object: 'batch';\r\n\r\n  /**\r\n   * The current status of the batch.\r\n   */\r\n  status:\r\n    | 'validating'\r\n    | 'failed'\r\n    | 'in_progress'\r\n    | 'finalizing'\r\n    | 'completed'\r\n    | 'expired'\r\n    | 'cancelling'\r\n    | 'cancelled';\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the batch was cancelled.\r\n   */\r\n  cancelled_at?: number;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the batch started cancelling.\r\n   */\r\n  cancelling_at?: number;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the batch was completed.\r\n   */\r\n  completed_at?: number;\r\n\r\n  /**\r\n   * The ID of the file containing the outputs of requests with errors.\r\n   */\r\n  error_file_id?: string;\r\n\r\n  errors?: BatchRetrieveResponse.Errors;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the batch expired.\r\n   */\r\n  expired_at?: number;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the batch will expire.\r\n   */\r\n  expires_at?: number;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the batch failed.\r\n   */\r\n  failed_at?: number;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the batch started finalizing.\r\n   */\r\n  finalizing_at?: number;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the batch started processing.\r\n   */\r\n  in_progress_at?: number;\r\n\r\n  /**\r\n   * Set of key-value pairs that can be attached to an object. This can be useful for\r\n   * storing additional information about the object in a structured format.\r\n   */\r\n  metadata?: unknown | null;\r\n\r\n  /**\r\n   * The ID of the file containing the outputs of successfully executed requests.\r\n   */\r\n  output_file_id?: string;\r\n\r\n  /**\r\n   * The request counts for different statuses within the batch.\r\n   */\r\n  request_counts?: BatchRetrieveResponse.RequestCounts;\r\n}\r\n\r\nexport namespace BatchRetrieveResponse {\r\n  export interface Errors {\r\n    data?: Array<Errors.Data>;\r\n\r\n    /**\r\n     * The object type, which is always `list`.\r\n     */\r\n    object?: string;\r\n  }\r\n\r\n  export namespace Errors {\r\n    export interface Data {\r\n      /**\r\n       * An error code identifying the error type.\r\n       */\r\n      code?: string;\r\n\r\n      /**\r\n       * The line number of the input file where the error occurred, if applicable.\r\n       */\r\n      line?: number | null;\r\n\r\n      /**\r\n       * A human-readable message providing more details about the error.\r\n       */\r\n      message?: string;\r\n\r\n      /**\r\n       * The name of the parameter that caused the error, if applicable.\r\n       */\r\n      param?: string | null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The request counts for different statuses within the batch.\r\n   */\r\n  export interface RequestCounts {\r\n    /**\r\n     * Number of requests that have been completed successfully.\r\n     */\r\n    completed: number;\r\n\r\n    /**\r\n     * Number of requests that have failed.\r\n     */\r\n    failed: number;\r\n\r\n    /**\r\n     * Total number of requests in the batch.\r\n     */\r\n    total: number;\r\n  }\r\n}\r\n\r\nexport interface BatchListResponse {\r\n  data: Array<BatchListResponse.Data>;\r\n\r\n  object: 'list';\r\n}\r\n\r\nexport namespace BatchListResponse {\r\n  export interface Data {\r\n    id: string;\r\n\r\n    /**\r\n     * The time frame within which the batch should be processed.\r\n     */\r\n    completion_window: string;\r\n\r\n    /**\r\n     * The Unix timestamp (in seconds) for when the batch was created.\r\n     */\r\n    created_at: number;\r\n\r\n    /**\r\n     * The API endpoint used by the batch.\r\n     */\r\n    endpoint: string;\r\n\r\n    /**\r\n     * The ID of the input file for the batch.\r\n     */\r\n    input_file_id: string;\r\n\r\n    /**\r\n     * The object type, which is always `batch`.\r\n     */\r\n    object: 'batch';\r\n\r\n    /**\r\n     * The current status of the batch.\r\n     */\r\n    status:\r\n      | 'validating'\r\n      | 'failed'\r\n      | 'in_progress'\r\n      | 'finalizing'\r\n      | 'completed'\r\n      | 'expired'\r\n      | 'cancelling'\r\n      | 'cancelled';\r\n\r\n    /**\r\n     * The Unix timestamp (in seconds) for when the batch was cancelled.\r\n     */\r\n    cancelled_at?: number;\r\n\r\n    /**\r\n     * The Unix timestamp (in seconds) for when the batch started cancelling.\r\n     */\r\n    cancelling_at?: number;\r\n\r\n    /**\r\n     * The Unix timestamp (in seconds) for when the batch was completed.\r\n     */\r\n    completed_at?: number;\r\n\r\n    /**\r\n     * The ID of the file containing the outputs of requests with errors.\r\n     */\r\n    error_file_id?: string;\r\n\r\n    errors?: Data.Errors;\r\n\r\n    /**\r\n     * The Unix timestamp (in seconds) for when the batch expired.\r\n     */\r\n    expired_at?: number;\r\n\r\n    /**\r\n     * The Unix timestamp (in seconds) for when the batch will expire.\r\n     */\r\n    expires_at?: number;\r\n\r\n    /**\r\n     * The Unix timestamp (in seconds) for when the batch failed.\r\n     */\r\n    failed_at?: number;\r\n\r\n    /**\r\n     * The Unix timestamp (in seconds) for when the batch started finalizing.\r\n     */\r\n    finalizing_at?: number;\r\n\r\n    /**\r\n     * The Unix timestamp (in seconds) for when the batch started processing.\r\n     */\r\n    in_progress_at?: number;\r\n\r\n    /**\r\n     * Set of key-value pairs that can be attached to an object. This can be useful for\r\n     * storing additional information about the object in a structured format.\r\n     */\r\n    metadata?: unknown | null;\r\n\r\n    /**\r\n     * The ID of the file containing the outputs of successfully executed requests.\r\n     */\r\n    output_file_id?: string;\r\n\r\n    /**\r\n     * The request counts for different statuses within the batch.\r\n     */\r\n    request_counts?: Data.RequestCounts;\r\n  }\r\n\r\n  export namespace Data {\r\n    export interface Errors {\r\n      data?: Array<Errors.Data>;\r\n\r\n      /**\r\n       * The object type, which is always `list`.\r\n       */\r\n      object?: string;\r\n    }\r\n\r\n    export namespace Errors {\r\n      export interface Data {\r\n        /**\r\n         * An error code identifying the error type.\r\n         */\r\n        code?: string;\r\n\r\n        /**\r\n         * The line number of the input file where the error occurred, if applicable.\r\n         */\r\n        line?: number | null;\r\n\r\n        /**\r\n         * A human-readable message providing more details about the error.\r\n         */\r\n        message?: string;\r\n\r\n        /**\r\n         * The name of the parameter that caused the error, if applicable.\r\n         */\r\n        param?: string | null;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * The request counts for different statuses within the batch.\r\n     */\r\n    export interface RequestCounts {\r\n      /**\r\n       * Number of requests that have been completed successfully.\r\n       */\r\n      completed: number;\r\n\r\n      /**\r\n       * Number of requests that have failed.\r\n       */\r\n      failed: number;\r\n\r\n      /**\r\n       * Total number of requests in the batch.\r\n       */\r\n      total: number;\r\n    }\r\n  }\r\n}\r\n\r\nexport interface BatchCreateParams {\r\n  /**\r\n   * The time frame within which the batch should be processed. Currently only `24h`\r\n   * is supported.\r\n   */\r\n  completion_window: '24h';\r\n\r\n  /**\r\n   * The endpoint to be used for all requests in the batch. Currently\r\n   * `/v1/chat/completions` is supported.\r\n   */\r\n  endpoint: '/v1/chat/completions';\r\n\r\n  /**\r\n   * The ID of an uploaded file that contains requests for the new batch.\r\n   *\r\n   * See [upload file](/docs/api-reference#files-upload) for how to upload a file.\r\n   *\r\n   * Your input file must be formatted as a [JSONL file](/docs/batch), and must be\r\n   * uploaded with the purpose `batch`. The file can be up to 100 MB in size.\r\n   */\r\n  input_file_id: string;\r\n\r\n  /**\r\n   * Optional custom metadata for the batch.\r\n   */\r\n  metadata?: Record<string, string> | null;\r\n}\r\n\r\nexport declare namespace Batches {\r\n  export {\r\n    type BatchCreateResponse as BatchCreateResponse,\r\n    type BatchRetrieveResponse as BatchRetrieveResponse,\r\n    type BatchListResponse as BatchListResponse,\r\n    type BatchCreateParams as BatchCreateParams,\r\n  };\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from '../../resource';\r\nimport * as Core from '../../core';\r\nimport * as ChatCompletionsAPI from './completions';\r\nimport * as CompletionsAPI from '../completions';\r\nimport * as Shared from '../shared';\r\nimport { Stream } from '../../lib/streaming';\r\n\r\nexport class Completions extends APIResource {\r\n  /**\r\n   * Creates a model response for the given chat conversation.\r\n   */\r\n  create(\r\n    body: ChatCompletionCreateParamsNonStreaming,\r\n    options?: Core.RequestOptions,\r\n  ): Core.APIPromise<ChatCompletion>;\r\n  create(\r\n    body: ChatCompletionCreateParamsStreaming,\r\n    options?: Core.RequestOptions,\r\n  ): Core.APIPromise<Stream<ChatCompletionChunk>>;\r\n  create(\r\n    body: ChatCompletionCreateParamsBase,\r\n    options?: Core.RequestOptions,\r\n  ): Core.APIPromise<Stream<ChatCompletionChunk> | ChatCompletion>;\r\n  create(\r\n    body: ChatCompletionCreateParams,\r\n    options?: Core.RequestOptions,\r\n  ): Core.APIPromise<ChatCompletion> | Core.APIPromise<Stream<ChatCompletionChunk>> {\r\n    return this._client.post('/openai/v1/chat/completions', {\r\n      body,\r\n      ...options,\r\n      stream: body.stream ?? false,\r\n    }) as Core.APIPromise<ChatCompletion> | Core.APIPromise<Stream<ChatCompletionChunk>>;\r\n  }\r\n}\r\n\r\n/**\r\n * Represents a chat completion response returned by model, based on the provided\r\n * input.\r\n */\r\nexport interface ChatCompletion {\r\n  /**\r\n   * A unique identifier for the chat completion.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * A list of chat completion choices. Can be more than one if `n` is greater\r\n   * than 1.\r\n   */\r\n  choices: Array<ChatCompletion.Choice>;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) of when the chat completion was created.\r\n   */\r\n  created: number;\r\n\r\n  /**\r\n   * The model used for the chat completion.\r\n   */\r\n  model: string;\r\n\r\n  /**\r\n   * The object type, which is always `chat.completion`.\r\n   */\r\n  object: 'chat.completion';\r\n\r\n  /**\r\n   * This fingerprint represents the backend configuration that the model runs with.\r\n   *\r\n   * Can be used in conjunction with the `seed` request parameter to understand when\r\n   * backend changes have been made that might impact determinism.\r\n   */\r\n  system_fingerprint?: string;\r\n\r\n  /**\r\n   * Usage statistics for the completion request.\r\n   */\r\n  usage?: CompletionsAPI.CompletionUsage;\r\n}\r\n\r\nexport namespace ChatCompletion {\r\n  export interface Choice {\r\n    /**\r\n     * The reason the model stopped generating tokens. This will be `stop` if the model\r\n     * hit a natural stop point or a provided stop sequence, `length` if the maximum\r\n     * number of tokens specified in the request was reached, `tool_calls` if the model\r\n     * called a tool, or `function_call` (deprecated) if the model called a function.\r\n     */\r\n    finish_reason: 'stop' | 'length' | 'tool_calls' | 'function_call';\r\n\r\n    /**\r\n     * The index of the choice in the list of choices.\r\n     */\r\n    index: number;\r\n\r\n    /**\r\n     * Log probability information for the choice.\r\n     */\r\n    logprobs: Choice.Logprobs | null;\r\n\r\n    /**\r\n     * A chat completion message generated by the model.\r\n     */\r\n    message: ChatCompletionsAPI.ChatCompletionMessage;\r\n  }\r\n\r\n  export namespace Choice {\r\n    /**\r\n     * Log probability information for the choice.\r\n     */\r\n    export interface Logprobs {\r\n      /**\r\n       * A list of message content tokens with log probability information.\r\n       */\r\n      content: Array<ChatCompletionsAPI.ChatCompletionTokenLogprob> | null;\r\n    }\r\n  }\r\n}\r\n\r\nexport interface ChatCompletionAssistantMessageParam {\r\n  /**\r\n   * The role of the messages author, in this case `assistant`.\r\n   */\r\n  role: 'assistant';\r\n\r\n  /**\r\n   * The contents of the assistant message. Required unless `tool_calls` or\r\n   * `function_call` is specified.\r\n   */\r\n  content?: string | null;\r\n\r\n  /**\r\n   * @deprecated Deprecated and replaced by `tool_calls`. The name and arguments of a\r\n   * function that should be called, as generated by the model.\r\n   */\r\n  function_call?: ChatCompletionAssistantMessageParam.FunctionCall;\r\n\r\n  /**\r\n   * An optional name for the participant. Provides the model information to\r\n   * differentiate between participants of the same role.\r\n   */\r\n  name?: string;\r\n\r\n  /**\r\n   * The tool calls generated by the model, such as function calls.\r\n   */\r\n  tool_calls?: Array<ChatCompletionMessageToolCall>;\r\n}\r\n\r\nexport namespace ChatCompletionAssistantMessageParam {\r\n  /**\r\n   * @deprecated Deprecated and replaced by `tool_calls`. The name and arguments of a\r\n   * function that should be called, as generated by the model.\r\n   */\r\n  export interface FunctionCall {\r\n    /**\r\n     * The arguments to call the function with, as generated by the model in JSON\r\n     * format. Note that the model does not always generate valid JSON, and may\r\n     * hallucinate parameters not defined by your function schema. Validate the\r\n     * arguments in your code before calling your function.\r\n     */\r\n    arguments?: string;\r\n\r\n    /**\r\n     * The name of the function to call.\r\n     */\r\n    name?: string;\r\n  }\r\n}\r\n\r\n/**\r\n * Represents a streamed chunk of a chat completion response returned by model,\r\n * based on the provided input.\r\n */\r\nexport interface ChatCompletionChunk {\r\n  /**\r\n   * A unique identifier for the chat completion. Each chunk has the same ID.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * A list of chat completion choices. Can contain more than one elements if `n` is\r\n   * greater than 1.\r\n   */\r\n  choices: Array<ChatCompletionChunk.Choice>;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) of when the chat completion was created. Each\r\n   * chunk has the same timestamp.\r\n   */\r\n  created: number;\r\n\r\n  /**\r\n   * The model to generate the completion.\r\n   */\r\n  model: string;\r\n\r\n  /**\r\n   * The object type, which is always `chat.completion.chunk`.\r\n   */\r\n  object: 'chat.completion.chunk';\r\n\r\n  /**\r\n   * This fingerprint represents the backend configuration that the model runs with.\r\n   * Can be used in conjunction with the `seed` request parameter to understand when\r\n   * backend changes have been made that might impact determinism.\r\n   */\r\n  system_fingerprint?: string;\r\n\r\n  x_groq?: ChatCompletionChunk.XGroq;\r\n}\r\n\r\nexport namespace ChatCompletionChunk {\r\n  export interface Choice {\r\n    /**\r\n     * A chat completion delta generated by streamed model responses.\r\n     */\r\n    delta: Choice.Delta;\r\n\r\n    /**\r\n     * The reason the model stopped generating tokens. This will be `stop` if the model\r\n     * hit a natural stop point or a provided stop sequence, `length` if the maximum\r\n     * number of tokens specified in the request was reached, `tool_calls` if the model\r\n     * called a tool, or `function_call` (deprecated) if the model called a function.\r\n     */\r\n    finish_reason: 'stop' | 'length' | 'tool_calls' | 'function_call' | null;\r\n\r\n    /**\r\n     * The index of the choice in the list of choices.\r\n     */\r\n    index: number;\r\n\r\n    /**\r\n     * Log probability information for the choice.\r\n     */\r\n    logprobs?: Choice.Logprobs | null;\r\n  }\r\n\r\n  export namespace Choice {\r\n    /**\r\n     * A chat completion delta generated by streamed model responses.\r\n     */\r\n    export interface Delta {\r\n      /**\r\n       * The contents of the chunk message.\r\n       */\r\n      content?: string | null;\r\n\r\n      /**\r\n       * @deprecated Deprecated and replaced by `tool_calls`. The name and arguments of a\r\n       * function that should be called, as generated by the model.\r\n       */\r\n      function_call?: Delta.FunctionCall;\r\n\r\n      /**\r\n       * The model's reasoning for a response. Only available for reasoning models when\r\n       * requests parameter reasoning_format has value `parsed.\r\n       */\r\n      reasoning?: string | null;\r\n\r\n      /**\r\n       * The role of the author of this message.\r\n       */\r\n      role?: 'system' | 'user' | 'assistant' | 'tool';\r\n\r\n      tool_calls?: Array<Delta.ToolCall>;\r\n    }\r\n\r\n    export namespace Delta {\r\n      /**\r\n       * @deprecated Deprecated and replaced by `tool_calls`. The name and arguments of a\r\n       * function that should be called, as generated by the model.\r\n       */\r\n      export interface FunctionCall {\r\n        /**\r\n         * The arguments to call the function with, as generated by the model in JSON\r\n         * format. Note that the model does not always generate valid JSON, and may\r\n         * hallucinate parameters not defined by your function schema. Validate the\r\n         * arguments in your code before calling your function.\r\n         */\r\n        arguments?: string;\r\n\r\n        /**\r\n         * The name of the function to call.\r\n         */\r\n        name?: string;\r\n      }\r\n\r\n      export interface ToolCall {\r\n        index: number;\r\n\r\n        /**\r\n         * The ID of the tool call.\r\n         */\r\n        id?: string;\r\n\r\n        function?: ToolCall.Function;\r\n\r\n        /**\r\n         * The type of the tool. Currently, only `function` is supported.\r\n         */\r\n        type?: 'function';\r\n      }\r\n\r\n      export namespace ToolCall {\r\n        export interface Function {\r\n          /**\r\n           * The arguments to call the function with, as generated by the model in JSON\r\n           * format. Note that the model does not always generate valid JSON, and may\r\n           * hallucinate parameters not defined by your function schema. Validate the\r\n           * arguments in your code before calling your function.\r\n           */\r\n          arguments?: string;\r\n\r\n          /**\r\n           * The name of the function to call.\r\n           */\r\n          name?: string;\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Log probability information for the choice.\r\n     */\r\n    export interface Logprobs {\r\n      /**\r\n       * A list of message content tokens with log probability information.\r\n       */\r\n      content: Array<ChatCompletionsAPI.ChatCompletionTokenLogprob> | null;\r\n    }\r\n  }\r\n\r\n  export interface XGroq {\r\n    /**\r\n     * A groq request ID which can be used by to refer to a specific request to groq\r\n     * support Only sent with the first chunk\r\n     */\r\n    id?: string;\r\n\r\n    /**\r\n     * An error string indicating why a stream was stopped early\r\n     */\r\n    error?: string;\r\n\r\n    /**\r\n     * Usage information for the stream. Only sent in the final chunk\r\n     */\r\n    usage?: CompletionsAPI.CompletionUsage;\r\n  }\r\n}\r\n\r\nexport type ChatCompletionContentPart = ChatCompletionContentPartText | ChatCompletionContentPartImage;\r\n\r\nexport interface ChatCompletionContentPartImage {\r\n  image_url: ChatCompletionContentPartImage.ImageURL;\r\n\r\n  /**\r\n   * The type of the content part.\r\n   */\r\n  type: 'image_url';\r\n}\r\n\r\nexport namespace ChatCompletionContentPartImage {\r\n  export interface ImageURL {\r\n    /**\r\n     * Either a URL of the image or the base64 encoded image data.\r\n     */\r\n    url: string;\r\n\r\n    /**\r\n     * Specifies the detail level of the image.\r\n     */\r\n    detail?: 'auto' | 'low' | 'high';\r\n  }\r\n}\r\n\r\nexport interface ChatCompletionContentPartText {\r\n  /**\r\n   * The text content.\r\n   */\r\n  text: string;\r\n\r\n  /**\r\n   * The type of the content part.\r\n   */\r\n  type: 'text';\r\n}\r\n\r\n/**\r\n * Specifying a particular function via `{\"name\": \"my_function\"}` forces the model\r\n * to call that function.\r\n */\r\nexport interface ChatCompletionFunctionCallOption {\r\n  /**\r\n   * The name of the function to call.\r\n   */\r\n  name: string;\r\n}\r\n\r\n/**\r\n * @deprecated\r\n */\r\nexport interface ChatCompletionFunctionMessageParam {\r\n  /**\r\n   * The contents of the function message.\r\n   */\r\n  content: string | null;\r\n\r\n  /**\r\n   * The name of the function to call.\r\n   */\r\n  name: string;\r\n\r\n  /**\r\n   * The role of the messages author, in this case `function`.\r\n   */\r\n  role: 'function';\r\n}\r\n\r\n/**\r\n * A chat completion message generated by the model.\r\n */\r\nexport interface ChatCompletionMessage {\r\n  /**\r\n   * The contents of the message.\r\n   */\r\n  content: string | null;\r\n\r\n  /**\r\n   * The role of the author of this message.\r\n   */\r\n  role: 'assistant';\r\n\r\n  /**\r\n   * @deprecated Deprecated and replaced by `tool_calls`. The name and arguments of a\r\n   * function that should be called, as generated by the model.\r\n   */\r\n  function_call?: ChatCompletionMessage.FunctionCall;\r\n\r\n  /**\r\n   * The model's reasoning for a response. Only available for reasoning models when\r\n   * requests parameter reasoning_format has value `parsed.\r\n   */\r\n  reasoning?: string | null;\r\n\r\n  /**\r\n   * The tool calls generated by the model, such as function calls.\r\n   */\r\n  tool_calls?: Array<ChatCompletionMessageToolCall>;\r\n}\r\n\r\nexport namespace ChatCompletionMessage {\r\n  /**\r\n   * @deprecated Deprecated and replaced by `tool_calls`. The name and arguments of a\r\n   * function that should be called, as generated by the model.\r\n   */\r\n  export interface FunctionCall {\r\n    /**\r\n     * The arguments to call the function with, as generated by the model in JSON\r\n     * format. Note that the model does not always generate valid JSON, and may\r\n     * hallucinate parameters not defined by your function schema. Validate the\r\n     * arguments in your code before calling your function.\r\n     */\r\n    arguments: string;\r\n\r\n    /**\r\n     * The name of the function to call.\r\n     */\r\n    name: string;\r\n  }\r\n}\r\n\r\nexport type ChatCompletionMessageParam =\r\n  | ChatCompletionSystemMessageParam\r\n  | ChatCompletionUserMessageParam\r\n  | ChatCompletionAssistantMessageParam\r\n  | ChatCompletionToolMessageParam\r\n  | ChatCompletionFunctionMessageParam;\r\n\r\nexport interface ChatCompletionMessageToolCall {\r\n  /**\r\n   * The ID of the tool call.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * The function that the model called.\r\n   */\r\n  function: ChatCompletionMessageToolCall.Function;\r\n\r\n  /**\r\n   * The type of the tool. Currently, only `function` is supported.\r\n   */\r\n  type: 'function';\r\n}\r\n\r\nexport namespace ChatCompletionMessageToolCall {\r\n  /**\r\n   * The function that the model called.\r\n   */\r\n  export interface Function {\r\n    /**\r\n     * The arguments to call the function with, as generated by the model in JSON\r\n     * format. Note that the model does not always generate valid JSON, and may\r\n     * hallucinate parameters not defined by your function schema. Validate the\r\n     * arguments in your code before calling your function.\r\n     */\r\n    arguments: string;\r\n\r\n    /**\r\n     * The name of the function to call.\r\n     */\r\n    name: string;\r\n  }\r\n}\r\n\r\n/**\r\n * Specifies a tool the model should use. Use to force the model to call a specific\r\n * function.\r\n */\r\nexport interface ChatCompletionNamedToolChoice {\r\n  function: ChatCompletionNamedToolChoice.Function;\r\n\r\n  /**\r\n   * The type of the tool. Currently, only `function` is supported.\r\n   */\r\n  type: 'function';\r\n}\r\n\r\nexport namespace ChatCompletionNamedToolChoice {\r\n  export interface Function {\r\n    /**\r\n     * The name of the function to call.\r\n     */\r\n    name: string;\r\n  }\r\n}\r\n\r\n/**\r\n * The role of the author of a message\r\n */\r\nexport type ChatCompletionRole = 'system' | 'user' | 'assistant' | 'tool' | 'function';\r\n\r\nexport interface ChatCompletionSystemMessageParam {\r\n  /**\r\n   * The contents of the system message.\r\n   */\r\n  content: string;\r\n\r\n  /**\r\n   * The role of the messages author, in this case `system`.\r\n   */\r\n  role: 'system';\r\n\r\n  /**\r\n   * An optional name for the participant. Provides the model information to\r\n   * differentiate between participants of the same role.\r\n   */\r\n  name?: string;\r\n}\r\n\r\nexport interface ChatCompletionTokenLogprob {\r\n  /**\r\n   * The token.\r\n   */\r\n  token: string;\r\n\r\n  /**\r\n   * A list of integers representing the UTF-8 bytes representation of the token.\r\n   * Useful in instances where characters are represented by multiple tokens and\r\n   * their byte representations must be combined to generate the correct text\r\n   * representation. Can be `null` if there is no bytes representation for the token.\r\n   */\r\n  bytes: Array<number> | null;\r\n\r\n  /**\r\n   * The log probability of this token, if it is within the top 20 most likely\r\n   * tokens. Otherwise, the value `-9999.0` is used to signify that the token is very\r\n   * unlikely.\r\n   */\r\n  logprob: number;\r\n\r\n  /**\r\n   * List of the most likely tokens and their log probability, at this token\r\n   * position. In rare cases, there may be fewer than the number of requested\r\n   * `top_logprobs` returned.\r\n   */\r\n  top_logprobs: Array<ChatCompletionTokenLogprob.TopLogprob>;\r\n}\r\n\r\nexport namespace ChatCompletionTokenLogprob {\r\n  export interface TopLogprob {\r\n    /**\r\n     * The token.\r\n     */\r\n    token: string;\r\n\r\n    /**\r\n     * A list of integers representing the UTF-8 bytes representation of the token.\r\n     * Useful in instances where characters are represented by multiple tokens and\r\n     * their byte representations must be combined to generate the correct text\r\n     * representation. Can be `null` if there is no bytes representation for the token.\r\n     */\r\n    bytes: Array<number> | null;\r\n\r\n    /**\r\n     * The log probability of this token, if it is within the top 20 most likely\r\n     * tokens. Otherwise, the value `-9999.0` is used to signify that the token is very\r\n     * unlikely.\r\n     */\r\n    logprob: number;\r\n  }\r\n}\r\n\r\nexport interface ChatCompletionTool {\r\n  function: Shared.FunctionDefinition;\r\n\r\n  /**\r\n   * The type of the tool. Currently, only `function` is supported.\r\n   */\r\n  type: 'function';\r\n}\r\n\r\n/**\r\n * Controls which (if any) tool is called by the model. `none` means the model will\r\n * not call any tool and instead generates a message. `auto` means the model can\r\n * pick between generating a message or calling one or more tools. `required` means\r\n * the model must call one or more tools. Specifying a particular tool via\r\n * `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to\r\n * call that tool.\r\n *\r\n * `none` is the default when no tools are present. `auto` is the default if tools\r\n * are present.\r\n */\r\nexport type ChatCompletionToolChoiceOption = 'none' | 'auto' | 'required' | ChatCompletionNamedToolChoice;\r\n\r\nexport interface ChatCompletionToolMessageParam {\r\n  /**\r\n   * The contents of the tool message.\r\n   */\r\n  content: string;\r\n\r\n  /**\r\n   * The role of the messages author, in this case `tool`.\r\n   */\r\n  role: 'tool';\r\n\r\n  /**\r\n   * Tool call that this message is responding to.\r\n   */\r\n  tool_call_id: string;\r\n}\r\n\r\nexport interface ChatCompletionUserMessageParam {\r\n  /**\r\n   * The contents of the user message.\r\n   */\r\n  content: string | Array<ChatCompletionContentPart>;\r\n\r\n  /**\r\n   * The role of the messages author, in this case `user`.\r\n   */\r\n  role: 'user';\r\n\r\n  /**\r\n   * An optional name for the participant. Provides the model information to\r\n   * differentiate between participants of the same role.\r\n   */\r\n  name?: string;\r\n}\r\n\r\nexport type ChatCompletionCreateParams =\r\n  | ChatCompletionCreateParamsNonStreaming\r\n  | ChatCompletionCreateParamsStreaming;\r\n\r\nexport interface ChatCompletionCreateParamsBase {\r\n  /**\r\n   * A list of messages comprising the conversation so far.\r\n   */\r\n  messages: Array<ChatCompletionMessageParam>;\r\n\r\n  /**\r\n   * ID of the model to use. For details on which models are compatible with the Chat\r\n   * API, see available [models](/docs/models)\r\n   */\r\n  model: (string & {}) | 'gemma-7b-it' | 'llama3-70b-8192' | 'llama3-8b-8192' | 'mixtral-8x7b-32768';\r\n\r\n  /**\r\n   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their\r\n   * existing frequency in the text so far, decreasing the model's likelihood to\r\n   * repeat the same line verbatim.\r\n   */\r\n  frequency_penalty?: number | null;\r\n\r\n  /**\r\n   * Deprecated in favor of `tool_choice`.\r\n   *\r\n   * Controls which (if any) function is called by the model. `none` means the model\r\n   * will not call a function and instead generates a message. `auto` means the model\r\n   * can pick between generating a message or calling a function. Specifying a\r\n   * particular function via `{\"name\": \"my_function\"}` forces the model to call that\r\n   * function.\r\n   *\r\n   * `none` is the default when no functions are present. `auto` is the default if\r\n   * functions are present.\r\n   */\r\n  function_call?: 'none' | 'auto' | 'required' | ChatCompletionFunctionCallOption | null;\r\n\r\n  /**\r\n   * Deprecated in favor of `tools`.\r\n   *\r\n   * A list of functions the model may generate JSON inputs for.\r\n   */\r\n  functions?: Array<CompletionCreateParams.Function> | null;\r\n\r\n  /**\r\n   * This is not yet supported by any of our models. Modify the likelihood of\r\n   * specified tokens appearing in the completion.\r\n   */\r\n  logit_bias?: Record<string, number> | null;\r\n\r\n  /**\r\n   * This is not yet supported by any of our models. Whether to return log\r\n   * probabilities of the output tokens or not. If true, returns the log\r\n   * probabilities of each output token returned in the `content` of `message`.\r\n   */\r\n  logprobs?: boolean | null;\r\n\r\n  /**\r\n   * The maximum number of tokens that can be generated in the chat completion. The\r\n   * total length of input tokens and generated tokens is limited by the model's\r\n   * context length.\r\n   */\r\n  max_completion_tokens?: number | null;\r\n\r\n  /**\r\n   * Deprecated in favor of `max_completion_tokens`. The maximum number of tokens\r\n   * that can be generated in the chat completion. The total length of input tokens\r\n   * and generated tokens is limited by the model's context length.\r\n   */\r\n  max_tokens?: number | null;\r\n\r\n  /**\r\n   * How many chat completion choices to generate for each input message. Note that\r\n   * the current moment, only n=1 is supported. Other values will result in a 400\r\n   * response.\r\n   */\r\n  n?: number | null;\r\n\r\n  /**\r\n   * Whether to enable parallel function calling during tool use.\r\n   */\r\n  parallel_tool_calls?: boolean | null;\r\n\r\n  /**\r\n   * Number between -2.0 and 2.0. Positive values penalize new tokens based on\r\n   * whether they appear in the text so far, increasing the model's likelihood to\r\n   * talk about new topics.\r\n   */\r\n  presence_penalty?: number | null;\r\n\r\n  /**\r\n   * Specifies how to output reasoning tokens\r\n   */\r\n  reasoning_format?: 'hidden' | 'raw' | 'parsed' | null;\r\n\r\n  /**\r\n   * An object specifying the format that the model must output.\r\n   *\r\n   * Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which guarantees the\r\n   * message the model generates is valid JSON.\r\n   *\r\n   * **Important:** when using JSON mode, you **must** also instruct the model to\r\n   * produce JSON yourself via a system or user message.\r\n   */\r\n  response_format?: CompletionCreateParams.ResponseFormat | null;\r\n\r\n  /**\r\n   * If specified, our system will make a best effort to sample deterministically,\r\n   * such that repeated requests with the same `seed` and parameters should return\r\n   * the same result. Determinism is not guaranteed, and you should refer to the\r\n   * `system_fingerprint` response parameter to monitor changes in the backend.\r\n   */\r\n  seed?: number | null;\r\n\r\n  /**\r\n   * The service tier to use for the request. Defaults to `on_demand`.\r\n   *\r\n   * - `auto` will automatically select the highest tier available within the rate\r\n   *   limits of your organization.\r\n   * - `flex` uses the flex tier, which will succeed or fail quickly.\r\n   */\r\n  service_tier?: 'auto' | 'on_demand' | 'flex' | null;\r\n\r\n  /**\r\n   * Up to 4 sequences where the API will stop generating further tokens. The\r\n   * returned text will not contain the stop sequence.\r\n   */\r\n  stop?: string | null | Array<string>;\r\n\r\n  /**\r\n   * If set, partial message deltas will be sent. Tokens will be sent as data-only\r\n   * [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format)\r\n   * as they become available, with the stream terminated by a `data: [DONE]`\r\n   * message. [Example code](/docs/text-chat#streaming-a-chat-completion).\r\n   */\r\n  stream?: boolean | null;\r\n\r\n  /**\r\n   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will\r\n   * make the output more random, while lower values like 0.2 will make it more\r\n   * focused and deterministic. We generally recommend altering this or top_p but not\r\n   * both\r\n   */\r\n  temperature?: number | null;\r\n\r\n  /**\r\n   * Controls which (if any) tool is called by the model. `none` means the model will\r\n   * not call any tool and instead generates a message. `auto` means the model can\r\n   * pick between generating a message or calling one or more tools. `required` means\r\n   * the model must call one or more tools. Specifying a particular tool via\r\n   * `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to\r\n   * call that tool.\r\n   *\r\n   * `none` is the default when no tools are present. `auto` is the default if tools\r\n   * are present.\r\n   */\r\n  tool_choice?: ChatCompletionToolChoiceOption | null;\r\n\r\n  /**\r\n   * A list of tools the model may call. Currently, only functions are supported as a\r\n   * tool. Use this to provide a list of functions the model may generate JSON inputs\r\n   * for. A max of 128 functions are supported.\r\n   */\r\n  tools?: Array<ChatCompletionTool> | null;\r\n\r\n  /**\r\n   * This is not yet supported by any of our models. An integer between 0 and 20\r\n   * specifying the number of most likely tokens to return at each token position,\r\n   * each with an associated log probability. `logprobs` must be set to `true` if\r\n   * this parameter is used.\r\n   */\r\n  top_logprobs?: number | null;\r\n\r\n  /**\r\n   * An alternative to sampling with temperature, called nucleus sampling, where the\r\n   * model considers the results of the tokens with top_p probability mass. So 0.1\r\n   * means only the tokens comprising the top 10% probability mass are considered. We\r\n   * generally recommend altering this or temperature but not both.\r\n   */\r\n  top_p?: number | null;\r\n\r\n  /**\r\n   * A unique identifier representing your end-user, which can help us monitor and\r\n   * detect abuse.\r\n   */\r\n  user?: string | null;\r\n}\r\n\r\nexport namespace CompletionCreateParams {\r\n  /**\r\n   * @deprecated\r\n   */\r\n  export interface Function {\r\n    /**\r\n     * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain\r\n     * underscores and dashes, with a maximum length of 64.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * A description of what the function does, used by the model to choose when and\r\n     * how to call the function.\r\n     */\r\n    description?: string;\r\n\r\n    /**\r\n     * The parameters the functions accepts, described as a JSON Schema object. See the\r\n     * docs on [tool use](/docs/tool-use) for examples, and the\r\n     * [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for\r\n     * documentation about the format.\r\n     *\r\n     * Omitting `parameters` defines a function with an empty parameter list.\r\n     */\r\n    parameters?: Shared.FunctionParameters;\r\n  }\r\n\r\n  /**\r\n   * An object specifying the format that the model must output.\r\n   *\r\n   * Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which guarantees the\r\n   * message the model generates is valid JSON.\r\n   *\r\n   * **Important:** when using JSON mode, you **must** also instruct the model to\r\n   * produce JSON yourself via a system or user message.\r\n   */\r\n  export interface ResponseFormat {\r\n    /**\r\n     * Must be one of `text` or `json_object`.\r\n     */\r\n    type?: 'text' | 'json_object';\r\n  }\r\n}\r\n\r\nexport interface ChatCompletionCreateParamsNonStreaming extends ChatCompletionCreateParamsBase {\r\n  /**\r\n   * If set, partial message deltas will be sent. Tokens will be sent as data-only\r\n   * [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format)\r\n   * as they become available, with the stream terminated by a `data: [DONE]`\r\n   * message. [Example code](/docs/text-chat#streaming-a-chat-completion).\r\n   */\r\n  stream?: false | null;\r\n}\r\n\r\nexport interface ChatCompletionCreateParamsStreaming extends ChatCompletionCreateParamsBase {\r\n  /**\r\n   * If set, partial message deltas will be sent. Tokens will be sent as data-only\r\n   * [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format)\r\n   * as they become available, with the stream terminated by a `data: [DONE]`\r\n   * message. [Example code](/docs/text-chat#streaming-a-chat-completion).\r\n   */\r\n  stream: true;\r\n}\r\n\r\nexport declare namespace Completions {\r\n  export {\r\n    type ChatCompletion as ChatCompletion,\r\n    type ChatCompletionAssistantMessageParam as ChatCompletionAssistantMessageParam,\r\n    type ChatCompletionChunk as ChatCompletionChunk,\r\n    type ChatCompletionContentPart as ChatCompletionContentPart,\r\n    type ChatCompletionContentPartImage as ChatCompletionContentPartImage,\r\n    type ChatCompletionContentPartText as ChatCompletionContentPartText,\r\n    type ChatCompletionFunctionCallOption as ChatCompletionFunctionCallOption,\r\n    type ChatCompletionFunctionMessageParam as ChatCompletionFunctionMessageParam,\r\n    type ChatCompletionMessage as ChatCompletionMessage,\r\n    type ChatCompletionMessageParam as ChatCompletionMessageParam,\r\n    type ChatCompletionMessageToolCall as ChatCompletionMessageToolCall,\r\n    type ChatCompletionNamedToolChoice as ChatCompletionNamedToolChoice,\r\n    type ChatCompletionRole as ChatCompletionRole,\r\n    type ChatCompletionSystemMessageParam as ChatCompletionSystemMessageParam,\r\n    type ChatCompletionTokenLogprob as ChatCompletionTokenLogprob,\r\n    type ChatCompletionTool as ChatCompletionTool,\r\n    type ChatCompletionToolChoiceOption as ChatCompletionToolChoiceOption,\r\n    type ChatCompletionToolMessageParam as ChatCompletionToolMessageParam,\r\n    type ChatCompletionUserMessageParam as ChatCompletionUserMessageParam,\r\n    type CompletionCreateParams as CompletionCreateParams,\r\n  };\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from '../../resource';\r\nimport * as CompletionsAPI from './completions';\r\nimport {\r\n  ChatCompletion,\r\n  ChatCompletionAssistantMessageParam,\r\n  ChatCompletionChunk,\r\n  ChatCompletionContentPart,\r\n  ChatCompletionContentPartImage,\r\n  ChatCompletionContentPartText,\r\n  ChatCompletionFunctionCallOption,\r\n  ChatCompletionFunctionMessageParam,\r\n  ChatCompletionMessage,\r\n  ChatCompletionMessageParam,\r\n  ChatCompletionMessageToolCall,\r\n  ChatCompletionNamedToolChoice,\r\n  ChatCompletionRole,\r\n  ChatCompletionSystemMessageParam,\r\n  ChatCompletionTokenLogprob,\r\n  ChatCompletionTool,\r\n  ChatCompletionToolChoiceOption,\r\n  ChatCompletionToolMessageParam,\r\n  ChatCompletionUserMessageParam,\r\n  CompletionCreateParams,\r\n  Completions,\r\n} from './completions';\r\n\r\nexport class Chat extends APIResource {\r\n  completions: CompletionsAPI.Completions = new CompletionsAPI.Completions(this._client);\r\n}\r\n\r\nChat.Completions = Completions;\r\n\r\nexport declare namespace Chat {\r\n  export {\r\n    Completions as Completions,\r\n    type ChatCompletion as ChatCompletion,\r\n    type ChatCompletionAssistantMessageParam as ChatCompletionAssistantMessageParam,\r\n    type ChatCompletionChunk as ChatCompletionChunk,\r\n    type ChatCompletionContentPart as ChatCompletionContentPart,\r\n    type ChatCompletionContentPartImage as ChatCompletionContentPartImage,\r\n    type ChatCompletionContentPartText as ChatCompletionContentPartText,\r\n    type ChatCompletionFunctionCallOption as ChatCompletionFunctionCallOption,\r\n    type ChatCompletionFunctionMessageParam as ChatCompletionFunctionMessageParam,\r\n    type ChatCompletionMessage as ChatCompletionMessage,\r\n    type ChatCompletionMessageParam as ChatCompletionMessageParam,\r\n    type ChatCompletionMessageToolCall as ChatCompletionMessageToolCall,\r\n    type ChatCompletionNamedToolChoice as ChatCompletionNamedToolChoice,\r\n    type ChatCompletionRole as ChatCompletionRole,\r\n    type ChatCompletionSystemMessageParam as ChatCompletionSystemMessageParam,\r\n    type ChatCompletionTokenLogprob as ChatCompletionTokenLogprob,\r\n    type ChatCompletionTool as ChatCompletionTool,\r\n    type ChatCompletionToolChoiceOption as ChatCompletionToolChoiceOption,\r\n    type ChatCompletionToolMessageParam as ChatCompletionToolMessageParam,\r\n    type ChatCompletionUserMessageParam as ChatCompletionUserMessageParam,\r\n    type CompletionCreateParams as CompletionCreateParams,\r\n  };\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from '../resource';\r\n\r\nexport class Completions extends APIResource {}\r\n\r\n/**\r\n * Usage statistics for the completion request.\r\n */\r\nexport interface CompletionUsage {\r\n  /**\r\n   * Number of tokens in the generated completion.\r\n   */\r\n  completion_tokens: number;\r\n\r\n  /**\r\n   * Number of tokens in the prompt.\r\n   */\r\n  prompt_tokens: number;\r\n\r\n  /**\r\n   * Total number of tokens used in the request (prompt + completion).\r\n   */\r\n  total_tokens: number;\r\n\r\n  /**\r\n   * Time spent generating tokens\r\n   */\r\n  completion_time?: number;\r\n\r\n  /**\r\n   * Time spent processing input tokens\r\n   */\r\n  prompt_time?: number;\r\n\r\n  /**\r\n   * Time the requests was spent queued\r\n   */\r\n  queue_time?: number;\r\n\r\n  /**\r\n   * completion time and prompt time combined\r\n   */\r\n  total_time?: number;\r\n}\r\n\r\nexport declare namespace Completions {\r\n  export { type CompletionUsage as CompletionUsage };\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from '../resource';\r\nimport * as Core from '../core';\r\n\r\nexport class Embeddings extends APIResource {\r\n  /**\r\n   * Creates an embedding vector representing the input text.\r\n   */\r\n  create(\r\n    body: EmbeddingCreateParams,\r\n    options?: Core.RequestOptions,\r\n  ): Core.APIPromise<CreateEmbeddingResponse> {\r\n    return this._client.post('/openai/v1/embeddings', { body, ...options });\r\n  }\r\n}\r\n\r\nexport interface CreateEmbeddingResponse {\r\n  /**\r\n   * The list of embeddings generated by the model.\r\n   */\r\n  data: Array<Embedding>;\r\n\r\n  /**\r\n   * The name of the model used to generate the embedding.\r\n   */\r\n  model: string;\r\n\r\n  /**\r\n   * The object type, which is always \"list\".\r\n   */\r\n  object: 'list';\r\n\r\n  /**\r\n   * The usage information for the request.\r\n   */\r\n  usage: CreateEmbeddingResponse.Usage;\r\n}\r\n\r\nexport namespace CreateEmbeddingResponse {\r\n  /**\r\n   * The usage information for the request.\r\n   */\r\n  export interface Usage {\r\n    /**\r\n     * The number of tokens used by the prompt.\r\n     */\r\n    prompt_tokens: number;\r\n\r\n    /**\r\n     * The total number of tokens used by the request.\r\n     */\r\n    total_tokens: number;\r\n  }\r\n}\r\n\r\n/**\r\n * Represents an embedding vector returned by embedding endpoint.\r\n */\r\nexport interface Embedding {\r\n  /**\r\n   * The embedding vector, which is a list of floats. The length of vector depends on\r\n   * the model as listed in the [embedding guide](/docs/guides/embeddings).\r\n   */\r\n  embedding: Array<number> | string;\r\n\r\n  /**\r\n   * The index of the embedding in the list of embeddings.\r\n   */\r\n  index: number;\r\n\r\n  /**\r\n   * The object type, which is always \"embedding\".\r\n   */\r\n  object: 'embedding';\r\n}\r\n\r\nexport interface EmbeddingCreateParams {\r\n  /**\r\n   * Input text to embed, encoded as a string or array of tokens. To embed multiple\r\n   * inputs in a single request, pass an array of strings or array of token arrays.\r\n   * The input must not exceed the max input tokens for the model, cannot be an empty\r\n   * string, and any array must be 2048 dimensions or less.\r\n   */\r\n  input: string | Array<string>;\r\n\r\n  /**\r\n   * ID of the model to use.\r\n   */\r\n  model: (string & {}) | 'nomic-embed-text-v1_5';\r\n\r\n  /**\r\n   * The format to return the embeddings in. Can only be `float` or `base64`.\r\n   */\r\n  encoding_format?: 'float' | 'base64';\r\n\r\n  /**\r\n   * A unique identifier representing your end-user, which can help us monitor and\r\n   * detect abuse.\r\n   */\r\n  user?: string | null;\r\n}\r\n\r\nexport declare namespace Embeddings {\r\n  export {\r\n    type CreateEmbeddingResponse as CreateEmbeddingResponse,\r\n    type Embedding as Embedding,\r\n    type EmbeddingCreateParams as EmbeddingCreateParams,\r\n  };\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from '../resource';\r\nimport * as Core from '../core';\r\n\r\nexport class Files extends APIResource {\r\n  /**\r\n   * Upload a file that can be used across various endpoints.\r\n   *\r\n   * The Batch API only supports `.jsonl` files up to 100 MB in size. The input also\r\n   * has a specific required [format](/docs/batch).\r\n   *\r\n   * Please contact us if you need to increase these storage limits.\r\n   */\r\n  create(body: FileCreateParams, options?: Core.RequestOptions): Core.APIPromise<FileCreateResponse> {\r\n    return this._client.post('/openai/v1/files', Core.multipartFormRequestOptions({ body, ...options }));\r\n  }\r\n\r\n  /**\r\n   * Returns a list of files.\r\n   */\r\n  list(options?: Core.RequestOptions): Core.APIPromise<FileListResponse> {\r\n    return this._client.get('/openai/v1/files', options);\r\n  }\r\n\r\n  /**\r\n   * Delete a file.\r\n   */\r\n  delete(fileId: string, options?: Core.RequestOptions): Core.APIPromise<FileDeleteResponse> {\r\n    return this._client.delete(`/openai/v1/files/${fileId}`, options);\r\n  }\r\n\r\n  /**\r\n   * Returns the contents of the specified file.\r\n   */\r\n  content(fileId: string, options?: Core.RequestOptions): Core.APIPromise<string> {\r\n    return this._client.get(`/openai/v1/files/${fileId}/content`, options);\r\n  }\r\n\r\n  /**\r\n   * Returns information about a file.\r\n   */\r\n  info(fileId: string, options?: Core.RequestOptions): Core.APIPromise<FileInfoResponse> {\r\n    return this._client.get(`/openai/v1/files/${fileId}`, options);\r\n  }\r\n}\r\n\r\n/**\r\n * The `File` object represents a document that has been uploaded.\r\n */\r\nexport interface FileCreateResponse {\r\n  /**\r\n   * The file identifier, which can be referenced in the API endpoints.\r\n   */\r\n  id?: string;\r\n\r\n  /**\r\n   * The size of the file, in bytes.\r\n   */\r\n  bytes?: number;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the file was created.\r\n   */\r\n  created_at?: number;\r\n\r\n  /**\r\n   * The name of the file.\r\n   */\r\n  filename?: string;\r\n\r\n  /**\r\n   * The object type, which is always `file`.\r\n   */\r\n  object?: 'file';\r\n\r\n  /**\r\n   * The intended purpose of the file. Supported values are `batch`, and\r\n   * `batch_output`.\r\n   */\r\n  purpose?: 'batch' | 'batch_output';\r\n}\r\n\r\nexport interface FileListResponse {\r\n  data: Array<FileListResponse.Data>;\r\n\r\n  object: 'list';\r\n}\r\n\r\nexport namespace FileListResponse {\r\n  /**\r\n   * The `File` object represents a document that has been uploaded.\r\n   */\r\n  export interface Data {\r\n    /**\r\n     * The file identifier, which can be referenced in the API endpoints.\r\n     */\r\n    id?: string;\r\n\r\n    /**\r\n     * The size of the file, in bytes.\r\n     */\r\n    bytes?: number;\r\n\r\n    /**\r\n     * The Unix timestamp (in seconds) for when the file was created.\r\n     */\r\n    created_at?: number;\r\n\r\n    /**\r\n     * The name of the file.\r\n     */\r\n    filename?: string;\r\n\r\n    /**\r\n     * The object type, which is always `file`.\r\n     */\r\n    object?: 'file';\r\n\r\n    /**\r\n     * The intended purpose of the file. Supported values are `batch`, and\r\n     * `batch_output`.\r\n     */\r\n    purpose?: 'batch' | 'batch_output';\r\n  }\r\n}\r\n\r\nexport interface FileDeleteResponse {\r\n  id: string;\r\n\r\n  deleted: boolean;\r\n\r\n  object: 'file';\r\n}\r\n\r\nexport type FileContentResponse = string;\r\n\r\n/**\r\n * The `File` object represents a document that has been uploaded.\r\n */\r\nexport interface FileInfoResponse {\r\n  /**\r\n   * The file identifier, which can be referenced in the API endpoints.\r\n   */\r\n  id?: string;\r\n\r\n  /**\r\n   * The size of the file, in bytes.\r\n   */\r\n  bytes?: number;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the file was created.\r\n   */\r\n  created_at?: number;\r\n\r\n  /**\r\n   * The name of the file.\r\n   */\r\n  filename?: string;\r\n\r\n  /**\r\n   * The object type, which is always `file`.\r\n   */\r\n  object?: 'file';\r\n\r\n  /**\r\n   * The intended purpose of the file. Supported values are `batch`, and\r\n   * `batch_output`.\r\n   */\r\n  purpose?: 'batch' | 'batch_output';\r\n}\r\n\r\nexport interface FileCreateParams {\r\n  /**\r\n   * The File object (not file name) to be uploaded.\r\n   */\r\n  file: Core.Uploadable;\r\n\r\n  /**\r\n   * The intended purpose of the uploaded file. Use \"batch\" for\r\n   * [Batch API](/docs/api-reference#batches).\r\n   */\r\n  purpose: 'batch';\r\n}\r\n\r\nexport declare namespace Files {\r\n  export {\r\n    type FileCreateResponse as FileCreateResponse,\r\n    type FileListResponse as FileListResponse,\r\n    type FileDeleteResponse as FileDeleteResponse,\r\n    type FileContentResponse as FileContentResponse,\r\n    type FileInfoResponse as FileInfoResponse,\r\n    type FileCreateParams as FileCreateParams,\r\n  };\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from '../resource';\r\nimport * as Core from '../core';\r\n\r\nexport class Models extends APIResource {\r\n  /**\r\n   * Get a specific model\r\n   */\r\n  retrieve(model: string, options?: Core.RequestOptions): Core.APIPromise<Model> {\r\n    return this._client.get(`/openai/v1/models/${model}`, options);\r\n  }\r\n\r\n  /**\r\n   * get all available models\r\n   */\r\n  list(options?: Core.RequestOptions): Core.APIPromise<ModelListResponse> {\r\n    return this._client.get('/openai/v1/models', options);\r\n  }\r\n\r\n  /**\r\n   * Delete a model\r\n   */\r\n  delete(model: string, options?: Core.RequestOptions): Core.APIPromise<ModelDeleted> {\r\n    return this._client.delete(`/openai/v1/models/${model}`, options);\r\n  }\r\n}\r\n\r\n/**\r\n * Describes an OpenAI model offering that can be used with the API.\r\n */\r\nexport interface Model {\r\n  /**\r\n   * The model identifier, which can be referenced in the API endpoints.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) when the model was created.\r\n   */\r\n  created: number;\r\n\r\n  /**\r\n   * The object type, which is always \"model\".\r\n   */\r\n  object: 'model';\r\n\r\n  /**\r\n   * The organization that owns the model.\r\n   */\r\n  owned_by: string;\r\n}\r\n\r\nexport interface ModelDeleted {\r\n  id: string;\r\n\r\n  deleted: boolean;\r\n\r\n  object: string;\r\n}\r\n\r\nexport interface ModelListResponse {\r\n  data: Array<Model>;\r\n\r\n  object: 'list';\r\n}\r\n\r\nexport declare namespace Models {\r\n  export {\r\n    type Model as Model,\r\n    type ModelDeleted as ModelDeleted,\r\n    type ModelListResponse as ModelListResponse,\r\n  };\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { type Agent } from './_shims/index';\r\nimport * as Core from './core';\r\nimport * as Errors from './error';\r\nimport * as Uploads from './uploads';\r\nimport * as API from './resources/index';\r\nimport {\r\n  BatchCreateParams,\r\n  BatchCreateResponse,\r\n  BatchListResponse,\r\n  BatchRetrieveResponse,\r\n  Batches,\r\n} from './resources/batches';\r\nimport { CompletionUsage, Completions } from './resources/completions';\r\nimport {\r\n  CreateEmbeddingResponse,\r\n  Embedding,\r\n  EmbeddingCreateParams,\r\n  Embeddings,\r\n} from './resources/embeddings';\r\nimport {\r\n  FileContentResponse,\r\n  FileCreateParams,\r\n  FileCreateResponse,\r\n  FileDeleteResponse,\r\n  FileInfoResponse,\r\n  FileListResponse,\r\n  Files,\r\n} from './resources/files';\r\nimport { Model, ModelDeleted, ModelListResponse, Models } from './resources/models';\r\nimport { Audio } from './resources/audio/audio';\r\nimport { Chat } from './resources/chat/chat';\r\n\r\nexport interface ClientOptions {\r\n  /**\r\n   * Defaults to process.env['GROQ_API_KEY'].\r\n   */\r\n  apiKey?: string | undefined;\r\n\r\n  /**\r\n   * Override the default base URL for the API, e.g., \"https://api.example.com/v2/\"\r\n   *\r\n   * Defaults to process.env['GROQ_BASE_URL'].\r\n   */\r\n  baseURL?: string | null | undefined;\r\n\r\n  /**\r\n   * The maximum amount of time (in milliseconds) that the client should wait for a response\r\n   * from the server before timing out a single request.\r\n   *\r\n   * Note that request timeouts are retried by default, so in a worst-case scenario you may wait\r\n   * much longer than this timeout before the promise succeeds or fails.\r\n   */\r\n  timeout?: number | undefined;\r\n\r\n  /**\r\n   * An HTTP agent used to manage HTTP(S) connections.\r\n   *\r\n   * If not provided, an agent will be constructed by default in the Node.js environment,\r\n   * otherwise no agent is used.\r\n   */\r\n  httpAgent?: Agent | undefined;\r\n\r\n  /**\r\n   * Specify a custom `fetch` function implementation.\r\n   *\r\n   * If not provided, we use `node-fetch` on Node.js and otherwise expect that `fetch` is\r\n   * defined globally.\r\n   */\r\n  fetch?: Core.Fetch | undefined;\r\n\r\n  /**\r\n   * The maximum number of times that the client will retry a request in case of a\r\n   * temporary failure, like a network error or a 5XX error from the server.\r\n   *\r\n   * @default 2\r\n   */\r\n  maxRetries?: number | undefined;\r\n\r\n  /**\r\n   * Default headers to include with every request to the API.\r\n   *\r\n   * These can be removed in individual requests by explicitly setting the\r\n   * header to `undefined` or `null` in request options.\r\n   */\r\n  defaultHeaders?: Core.Headers | undefined;\r\n\r\n  /**\r\n   * Default query parameters to include with every request to the API.\r\n   *\r\n   * These can be removed in individual requests by explicitly setting the\r\n   * param to `undefined` in request options.\r\n   */\r\n  defaultQuery?: Core.DefaultQuery | undefined;\r\n\r\n  /**\r\n   * By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\r\n   * Only set this option to `true` if you understand the risks and have appropriate mitigations in place.\r\n   */\r\n  dangerouslyAllowBrowser?: boolean | undefined;\r\n}\r\n\r\n/**\r\n * API Client for interfacing with the Groq API.\r\n */\r\nexport class Groq extends Core.APIClient {\r\n  apiKey: string;\r\n\r\n  private _options: ClientOptions;\r\n\r\n  /**\r\n   * API Client for interfacing with the Groq API.\r\n   *\r\n   * @param {string | undefined} [opts.apiKey=process.env['GROQ_API_KEY'] ?? undefined]\r\n   * @param {string} [opts.baseURL=process.env['GROQ_BASE_URL'] ?? https://api.groq.com] - Override the default base URL for the API.\r\n   * @param {number} [opts.timeout=1 minute] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\r\n   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.\r\n   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\r\n   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\r\n   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.\r\n   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.\r\n   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\r\n   */\r\n  constructor({\r\n    baseURL = Core.readEnv('GROQ_BASE_URL'),\r\n    apiKey = Core.readEnv('GROQ_API_KEY'),\r\n    ...opts\r\n  }: ClientOptions = {}) {\r\n    if (apiKey === undefined) {\r\n      throw new Errors.GroqError(\r\n        \"The GROQ_API_KEY environment variable is missing or empty; either provide it, or instantiate the Groq client with an apiKey option, like new Groq({ apiKey: 'My API Key' }).\",\r\n      );\r\n    }\r\n\r\n    const options: ClientOptions = {\r\n      apiKey,\r\n      ...opts,\r\n      baseURL: baseURL || `https://api.groq.com`,\r\n    };\r\n\r\n    if (!options.dangerouslyAllowBrowser && Core.isRunningInBrowser()) {\r\n      throw new Errors.GroqError(\r\n        \"It looks like you're running in a browser-like environment.\\n\\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\\nIf you understand the risks and have appropriate mitigations in place,\\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\\n\\nnew Groq({ apiKey, dangerouslyAllowBrowser: true })\",\r\n      );\r\n    }\r\n\r\n    super({\r\n      baseURL: options.baseURL!,\r\n      timeout: options.timeout ?? 60000 /* 1 minute */,\r\n      httpAgent: options.httpAgent,\r\n      maxRetries: options.maxRetries,\r\n      fetch: options.fetch,\r\n    });\r\n\r\n    this._options = options;\r\n\r\n    this.apiKey = apiKey;\r\n  }\r\n\r\n  completions: API.Completions = new API.Completions(this);\r\n  chat: API.Chat = new API.Chat(this);\r\n  embeddings: API.Embeddings = new API.Embeddings(this);\r\n  audio: API.Audio = new API.Audio(this);\r\n  models: API.Models = new API.Models(this);\r\n  batches: API.Batches = new API.Batches(this);\r\n  files: API.Files = new API.Files(this);\r\n\r\n  protected override defaultQuery(): Core.DefaultQuery | undefined {\r\n    return this._options.defaultQuery;\r\n  }\r\n\r\n  protected override defaultHeaders(opts: Core.FinalRequestOptions): Core.Headers {\r\n    return {\r\n      ...super.defaultHeaders(opts),\r\n      ...this._options.defaultHeaders,\r\n    };\r\n  }\r\n\r\n  protected override authHeaders(opts: Core.FinalRequestOptions): Core.Headers {\r\n    return { Authorization: `Bearer ${this.apiKey}` };\r\n  }\r\n\r\n  static Groq = this;\r\n  static DEFAULT_TIMEOUT = 60000; // 1 minute\r\n\r\n  static GroqError = Errors.GroqError;\r\n  static APIError = Errors.APIError;\r\n  static APIConnectionError = Errors.APIConnectionError;\r\n  static APIConnectionTimeoutError = Errors.APIConnectionTimeoutError;\r\n  static APIUserAbortError = Errors.APIUserAbortError;\r\n  static NotFoundError = Errors.NotFoundError;\r\n  static ConflictError = Errors.ConflictError;\r\n  static RateLimitError = Errors.RateLimitError;\r\n  static BadRequestError = Errors.BadRequestError;\r\n  static AuthenticationError = Errors.AuthenticationError;\r\n  static InternalServerError = Errors.InternalServerError;\r\n  static PermissionDeniedError = Errors.PermissionDeniedError;\r\n  static UnprocessableEntityError = Errors.UnprocessableEntityError;\r\n\r\n  static toFile = Uploads.toFile;\r\n  static fileFromPath = Uploads.fileFromPath;\r\n}\r\n\r\nGroq.Completions = Completions;\r\nGroq.Chat = Chat;\r\nGroq.Embeddings = Embeddings;\r\nGroq.Audio = Audio;\r\nGroq.Models = Models;\r\nGroq.Batches = Batches;\r\nGroq.Files = Files;\r\nexport declare namespace Groq {\r\n  export type RequestOptions = Core.RequestOptions;\r\n\r\n  export { Completions as Completions, type CompletionUsage as CompletionUsage };\r\n\r\n  export { Chat as Chat };\r\n\r\n  export {\r\n    Embeddings as Embeddings,\r\n    type CreateEmbeddingResponse as CreateEmbeddingResponse,\r\n    type Embedding as Embedding,\r\n    type EmbeddingCreateParams as EmbeddingCreateParams,\r\n  };\r\n\r\n  export { Audio as Audio };\r\n\r\n  export {\r\n    Models as Models,\r\n    type Model as Model,\r\n    type ModelDeleted as ModelDeleted,\r\n    type ModelListResponse as ModelListResponse,\r\n  };\r\n\r\n  export {\r\n    Batches as Batches,\r\n    type BatchCreateResponse as BatchCreateResponse,\r\n    type BatchRetrieveResponse as BatchRetrieveResponse,\r\n    type BatchListResponse as BatchListResponse,\r\n    type BatchCreateParams as BatchCreateParams,\r\n  };\r\n\r\n  export {\r\n    Files as Files,\r\n    type FileCreateResponse as FileCreateResponse,\r\n    type FileListResponse as FileListResponse,\r\n    type FileDeleteResponse as FileDeleteResponse,\r\n    type FileContentResponse as FileContentResponse,\r\n    type FileInfoResponse as FileInfoResponse,\r\n    type FileCreateParams as FileCreateParams,\r\n  };\r\n\r\n  export type ErrorObject = API.ErrorObject;\r\n  export type FunctionDefinition = API.FunctionDefinition;\r\n  export type FunctionParameters = API.FunctionParameters;\r\n}\r\n\r\nexport { toFile, fileFromPath } from './uploads';\r\nexport {\r\n  GroqError,\r\n  APIError,\r\n  APIConnectionError,\r\n  APIConnectionTimeoutError,\r\n  APIUserAbortError,\r\n  NotFoundError,\r\n  ConflictError,\r\n  RateLimitError,\r\n  BadRequestError,\r\n  AuthenticationError,\r\n  InternalServerError,\r\n  PermissionDeniedError,\r\n  UnprocessableEntityError,\r\n} from './error';\r\n\r\nexport default Groq;\r\n"],
  "mappings": ";;;AAAO,IAAM,UAAU;;;AC0BhB,IAAI,OAAO;AACX,IAAI,OAAkC;AACtC,IAAIA,SAAoC;AACxC,IAAIC,WAAwC;AAC5C,IAAIC,YAA0C;AAC9C,IAAIC,WAAwC;AAC5C,IAAIC,YAA0C;AAC9C,IAAIC,QAAkC;AACtC,IAAIC,QAAkC;AACtC,IAAIC,kBAAsD;AAC1D,IAAI,6BAA8E;AAClF,IAAI,kBAAwD;AAC5D,IAAI,eAAkD;AACtD,IAAI,iBAAsD;AAE3D,SAAU,SAAS,OAAc,UAA6B,EAAE,MAAM,MAAK,GAAE;AACjF,MAAI,MAAM;AACR,UAAM,IAAI,MACR,qCAAqC,MAAM,IAAI,kDAAkD;;AAGrG,MAAI,MAAM;AACR,UAAM,IAAI,MACR,kCAAkC,MAAM,IAAI,sCAAsC,IAAI,KAAK;;AAG/F,SAAO,QAAQ;AACf,SAAO,MAAM;AACb,EAAAP,SAAQ,MAAM;AACd,EAAAC,WAAU,MAAM;AAChB,EAAAC,YAAW,MAAM;AACjB,EAAAC,WAAU,MAAM;AAChB,EAAAC,YAAW,MAAM;AACjB,EAAAC,QAAO,MAAM;AACb,EAAAC,QAAO,MAAM;AACb,EAAAC,kBAAiB,MAAM;AACvB,+BAA6B,MAAM;AACnC,oBAAkB,MAAM;AACxB,iBAAe,MAAM;AACrB,mBAAiB,MAAM;AACzB;;;AC/DM,IAAO,gBAAP,MAAoB;EACxB,YAAmB,MAAS;AAAT,SAAA,OAAA;EAAY;EAC/B,KAAK,OAAO,WAAW,IAAC;AACtB,WAAO;EACT;;;;ACAI,SAAU,WAAW,EAAE,iBAAgB,IAAqC,CAAA,GAAE;AAClF,QAAM,iBACJ,mBACE,kCACA;;;;AAKJ,MAAI,QAAQ,UAAU,WAAW;AACjC,MAAI;AAEF,aAAS;AAET,eAAW;AAEX,gBAAY;AAEZ,eAAW;WACJ,OAAO;AACd,UAAM,IAAI,MACR,iEACG,MAAc,OACjB,KAAK,cAAc,EAAE;;AAIzB,SAAO;IACL,MAAM;IACN,OAAO;IACP,SAAS;IACT,UAAU;IACV,SAAS;IACT;;MAEE,OAAO,aAAa,cAAc,WAChC,MAAM,SAAQ;;QAEZ,cAAA;AACE,gBAAM,IAAI,MACR,qFAAqF,cAAc,EAAE;QAEzG;;;IAGN,MACE,OAAO,SAAS,cAAc,OAC5B,MAAM,KAAI;MACR,cAAA;AACE,cAAM,IAAI,MACR,iFAAiF,cAAc,EAAE;MAErG;;IAGN;;MAEE,OAAO,SAAS,cAAc,OAC5B,MAAM,KAAI;;QAER,cAAA;AACE,gBAAM,IAAI,MACR,iFAAiF,cAAc,EAAE;QAErG;;;IAGN;;MAEE,OAAO,mBAAmB,cAAc,iBACtC,MAAM,eAAc;;QAElB,cAAA;AACE,gBAAM,IAAI,MACR,uFAAuF,cAAc,EAAE;QAE3G;;;IAGN,4BAA4B,OAE1B,MACA,UACgC;MAChC,GAAG;MACH,MAAM,IAAI,cAAc,IAAI;;IAE9B,iBAAiB,CAAC,QAAgB;IAClC,cAAc,MAAK;AACjB,YAAM,IAAI,MACR,kJAAkJ;IAEtJ;IACA,gBAAgB,CAAC,UAAe;;AAEpC;;;ACjGA,IAAI,CAAO;AAAM,EAAM,SAAc,WAAW,GAAG,EAAE,MAAM,KAAK,CAAC;;;ACD3D,IAAO,YAAP,cAAyB,MAAK;;AAE9B,IAAO,WAAP,MAAO,kBAIH,UAAS;EAQjB,YAAY,QAAiB,OAAe,SAA6B,SAAiB;AACxF,UAAM,GAAG,UAAS,YAAY,QAAQ,OAAO,OAAO,CAAC,EAAE;AACvD,SAAK,SAAS;AACd,SAAK,UAAU;AACf,SAAK,QAAQ;EACf;EAEQ,OAAO,YAAY,QAA4B,OAAY,SAA2B;AAC5F,UAAM,OACJ,+BAAO,WACL,OAAO,MAAM,YAAY,WACvB,MAAM,UACN,KAAK,UAAU,MAAM,OAAO,IAC9B,QAAQ,KAAK,UAAU,KAAK,IAC5B;AAEJ,QAAI,UAAU,KAAK;AACjB,aAAO,GAAG,MAAM,IAAI,GAAG;;AAEzB,QAAI,QAAQ;AACV,aAAO,GAAG,MAAM;;AAElB,QAAI,KAAK;AACP,aAAO;;AAET,WAAO;EACT;EAEA,OAAO,SACL,QACA,eACA,SACA,SAA4B;AAE5B,QAAI,CAAC,UAAU,CAAC,SAAS;AACvB,aAAO,IAAI,mBAAmB,EAAE,SAAS,OAAO,YAAY,aAAa,EAAC,CAAE;;AAG9E,UAAM,QAAQ;AAEd,QAAI,WAAW,KAAK;AAClB,aAAO,IAAI,gBAAgB,QAAQ,OAAO,SAAS,OAAO;;AAG5D,QAAI,WAAW,KAAK;AAClB,aAAO,IAAI,oBAAoB,QAAQ,OAAO,SAAS,OAAO;;AAGhE,QAAI,WAAW,KAAK;AAClB,aAAO,IAAI,sBAAsB,QAAQ,OAAO,SAAS,OAAO;;AAGlE,QAAI,WAAW,KAAK;AAClB,aAAO,IAAI,cAAc,QAAQ,OAAO,SAAS,OAAO;;AAG1D,QAAI,WAAW,KAAK;AAClB,aAAO,IAAI,cAAc,QAAQ,OAAO,SAAS,OAAO;;AAG1D,QAAI,WAAW,KAAK;AAClB,aAAO,IAAI,yBAAyB,QAAQ,OAAO,SAAS,OAAO;;AAGrE,QAAI,WAAW,KAAK;AAClB,aAAO,IAAI,eAAe,QAAQ,OAAO,SAAS,OAAO;;AAG3D,QAAI,UAAU,KAAK;AACjB,aAAO,IAAI,oBAAoB,QAAQ,OAAO,SAAS,OAAO;;AAGhE,WAAO,IAAI,UAAS,QAAQ,OAAO,SAAS,OAAO;EACrD;;AAGI,IAAO,oBAAP,cAAiC,SAAyC;EAC9E,YAAY,EAAE,QAAO,IAA2B,CAAA,GAAE;AAChD,UAAM,QAAW,QAAW,WAAW,wBAAwB,MAAS;EAC1E;;AAGI,IAAO,qBAAP,cAAkC,SAAyC;EAC/E,YAAY,EAAE,SAAS,MAAK,GAA+D;AACzF,UAAM,QAAW,QAAW,WAAW,qBAAqB,MAAS;AAGrE,QAAI;AAAO,WAAK,QAAQ;EAC1B;;AAGI,IAAO,4BAAP,cAAyC,mBAAkB;EAC/D,YAAY,EAAE,QAAO,IAA2B,CAAA,GAAE;AAChD,UAAM,EAAE,SAAS,WAAW,qBAAoB,CAAE;EACpD;;AAGI,IAAO,kBAAP,cAA+B,SAAsB;;AAErD,IAAO,sBAAP,cAAmC,SAAsB;;AAEzD,IAAO,wBAAP,cAAqC,SAAsB;;AAE3D,IAAO,gBAAP,cAA6B,SAAsB;;AAEnD,IAAO,gBAAP,cAA6B,SAAsB;;AAEnD,IAAO,2BAAP,cAAwC,SAAsB;;AAE9D,IAAO,iBAAP,cAA8B,SAAsB;;AAEpD,IAAO,sBAAP,cAAmC,SAAyB;;;;ACpH5D,IAAO,SAAP,MAAO,QAAM;EAGjB,YACU,UACR,YAA2B;AADnB,SAAA,WAAA;AAGR,SAAK,aAAa;EACpB;EAEA,OAAO,gBAAsB,UAAoB,YAA2B;AAC1E,QAAI,WAAW;AACf,UAAM,UAAU,IAAI,WAAU;AAE9B,oBAAgB,eAAY;AAC1B,UAAI,CAAC,SAAS,MAAM;AAClB,mBAAW,MAAK;AAChB,cAAM,IAAI,UAAU,mDAAmD;;AAGzE,YAAM,cAAc,IAAI,YAAW;AAEnC,YAAM,OAAO,4BAAmC,SAAS,IAAI;AAC7D,uBAAiB,SAAS,MAAM;AAC9B,mBAAW,QAAQ,YAAY,OAAO,KAAK,GAAG;AAC5C,gBAAM,MAAM,QAAQ,OAAO,IAAI;AAC/B,cAAI;AAAK,kBAAM;;;AAInB,iBAAW,QAAQ,YAAY,MAAK,GAAI;AACtC,cAAM,MAAM,QAAQ,OAAO,IAAI;AAC/B,YAAI;AAAK,gBAAM;;IAEnB;AAEA,oBAAgB,WAAQ;AACtB,UAAI,UAAU;AACZ,cAAM,IAAI,MAAM,0EAA0E;;AAE5F,iBAAW;AACX,UAAI,OAAO;AACX,UAAI;AACF,yBAAiB,OAAO,aAAY,GAAI;AACtC,cAAI;AAAM;AAEV,cAAI,IAAI,KAAK,WAAW,QAAQ,GAAG;AACjC,mBAAO;AACP;;AAGF,cAAI,IAAI,UAAU,QAAQ,IAAI,UAAU,SAAS;AAC/C,gBAAI;AAEJ,gBAAI;AACF,qBAAO,KAAK,MAAM,IAAI,IAAI;qBACnB,GAAG;AACV,sBAAQ,MAAM,sCAAsC,IAAI,IAAI;AAC5D,sBAAQ,MAAM,eAAe,IAAI,GAAG;AACpC,oBAAM;;AAGR,gBAAI,QAAQ,KAAK,OAAO;AACtB,oBAAM,IAAI,SAAS,KAAK,MAAM,aAAa,KAAK,OAAO,KAAK,MAAM,SAAS,MAAS;;AAGtF,kBAAM;;;AAGV,eAAO;eACA,GAAG;AAEV,YAAI,aAAa,SAAS,EAAE,SAAS;AAAc;AACnD,cAAM;;AAGN,YAAI,CAAC;AAAM,qBAAW,MAAK;;IAE/B;AAEA,WAAO,IAAI,QAAO,UAAU,UAAU;EACxC;;;;;EAMA,OAAO,mBAAyB,gBAAgC,YAA2B;AACzF,QAAI,WAAW;AAEf,oBAAgB,YAAS;AACvB,YAAM,cAAc,IAAI,YAAW;AAEnC,YAAM,OAAO,4BAAmC,cAAc;AAC9D,uBAAiB,SAAS,MAAM;AAC9B,mBAAW,QAAQ,YAAY,OAAO,KAAK,GAAG;AAC5C,gBAAM;;;AAIV,iBAAW,QAAQ,YAAY,MAAK,GAAI;AACtC,cAAM;;IAEV;AAEA,oBAAgB,WAAQ;AACtB,UAAI,UAAU;AACZ,cAAM,IAAI,MAAM,0EAA0E;;AAE5F,iBAAW;AACX,UAAI,OAAO;AACX,UAAI;AACF,yBAAiB,QAAQ,UAAS,GAAI;AACpC,cAAI;AAAM;AACV,cAAI;AAAM,kBAAM,KAAK,MAAM,IAAI;;AAEjC,eAAO;eACA,GAAG;AAEV,YAAI,aAAa,SAAS,EAAE,SAAS;AAAc;AACnD,cAAM;;AAGN,YAAI,CAAC;AAAM,qBAAW,MAAK;;IAE/B;AAEA,WAAO,IAAI,QAAO,UAAU,UAAU;EACxC;EAEA,CAAC,OAAO,aAAa,IAAC;AACpB,WAAO,KAAK,SAAQ;EACtB;;;;;EAMA,MAAG;AACD,UAAM,OAA6C,CAAA;AACnD,UAAM,QAA8C,CAAA;AACpD,UAAM,WAAW,KAAK,SAAQ;AAE9B,UAAM,cAAc,CAAC,UAAoE;AACvF,aAAO;QACL,MAAM,MAAK;AACT,cAAI,MAAM,WAAW,GAAG;AACtB,kBAAM,SAAS,SAAS,KAAI;AAC5B,iBAAK,KAAK,MAAM;AAChB,kBAAM,KAAK,MAAM;;AAEnB,iBAAO,MAAM,MAAK;QACpB;;IAEJ;AAEA,WAAO;MACL,IAAI,QAAO,MAAM,YAAY,IAAI,GAAG,KAAK,UAAU;MACnD,IAAI,QAAO,MAAM,YAAY,KAAK,GAAG,KAAK,UAAU;;EAExD;;;;;;EAOA,mBAAgB;AACd,UAAM,OAAO;AACb,QAAI;AACJ,UAAM,UAAU,IAAI,YAAW;AAE/B,WAAO,IAAIC,gBAAe;MACxB,MAAM,QAAK;AACT,eAAO,KAAK,OAAO,aAAa,EAAC;MACnC;MACA,MAAM,KAAK,MAAI;AACb,YAAI;AACF,gBAAM,EAAE,OAAO,KAAI,IAAK,MAAM,KAAK,KAAI;AACvC,cAAI;AAAM,mBAAO,KAAK,MAAK;AAE3B,gBAAM,QAAQ,QAAQ,OAAO,KAAK,UAAU,KAAK,IAAI,IAAI;AAEzD,eAAK,QAAQ,KAAK;iBACX,KAAK;AACZ,eAAK,MAAM,GAAG;;MAElB;MACA,MAAM,SAAM;;AACV,gBAAMC,MAAA,KAAK,WAAL,gBAAAA,IAAA;MACR;KACD;EACH;;AAGF,IAAM,aAAN,MAAgB;EAKd,cAAA;AACE,SAAK,QAAQ;AACb,SAAK,OAAO,CAAA;AACZ,SAAK,SAAS,CAAA;EAChB;EAEA,OAAO,MAAY;AACjB,QAAI,KAAK,SAAS,IAAI,GAAG;AACvB,aAAO,KAAK,UAAU,GAAG,KAAK,SAAS,CAAC;;AAG1C,QAAI,CAAC,MAAM;AAET,UAAI,CAAC,KAAK,SAAS,CAAC,KAAK,KAAK;AAAQ,eAAO;AAE7C,YAAM,MAAuB;QAC3B,OAAO,KAAK;QACZ,MAAM,KAAK,KAAK,KAAK,IAAI;QACzB,KAAK,KAAK;;AAGZ,WAAK,QAAQ;AACb,WAAK,OAAO,CAAA;AACZ,WAAK,SAAS,CAAA;AAEd,aAAO;;AAGT,SAAK,OAAO,KAAK,IAAI;AAErB,QAAI,KAAK,WAAW,GAAG,GAAG;AACxB,aAAO;;AAGT,QAAI,CAAC,WAAW,GAAG,KAAK,IAAI,UAAU,MAAM,GAAG;AAE/C,QAAI,MAAM,WAAW,GAAG,GAAG;AACzB,cAAQ,MAAM,UAAU,CAAC;;AAG3B,QAAI,cAAc,SAAS;AACzB,WAAK,QAAQ;eACJ,cAAc,QAAQ;AAC/B,WAAK,KAAK,KAAK,KAAK;;AAGtB,WAAO;EACT;;AASF,IAAM,cAAN,MAAM,aAAW;EASf,cAAA;AACE,SAAK,SAAS,CAAA;AACd,SAAK,aAAa;EACpB;EAEA,OAAO,OAAY;AACjB,QAAI,OAAO,KAAK,WAAW,KAAK;AAEhC,QAAI,KAAK,YAAY;AACnB,aAAO,OAAO;AACd,WAAK,aAAa;;AAEpB,QAAI,KAAK,SAAS,IAAI,GAAG;AACvB,WAAK,aAAa;AAClB,aAAO,KAAK,MAAM,GAAG,EAAE;;AAGzB,QAAI,CAAC,MAAM;AACT,aAAO,CAAA;;AAGT,UAAM,kBAAkB,aAAY,cAAc,IAAI,KAAK,KAAK,SAAS,CAAC,KAAK,EAAE;AACjF,QAAI,QAAQ,KAAK,MAAM,aAAY,cAAc;AAEjD,QAAI,MAAM,WAAW,KAAK,CAAC,iBAAiB;AAC1C,WAAK,OAAO,KAAK,MAAM,CAAC,CAAE;AAC1B,aAAO,CAAA;;AAGT,QAAI,KAAK,OAAO,SAAS,GAAG;AAC1B,cAAQ,CAAC,KAAK,OAAO,KAAK,EAAE,IAAI,MAAM,CAAC,GAAG,GAAG,MAAM,MAAM,CAAC,CAAC;AAC3D,WAAK,SAAS,CAAA;;AAGhB,QAAI,CAAC,iBAAiB;AACpB,WAAK,SAAS,CAAC,MAAM,IAAG,KAAM,EAAE;;AAGlC,WAAO;EACT;EAEA,WAAW,OAAY;AACrB,QAAI,SAAS;AAAM,aAAO;AAC1B,QAAI,OAAO,UAAU;AAAU,aAAO;AAGtC,QAAI,OAAO,WAAW,aAAa;AACjC,UAAI,iBAAiB,QAAQ;AAC3B,eAAO,MAAM,SAAQ;;AAEvB,UAAI,iBAAiB,YAAY;AAC/B,eAAO,OAAO,KAAK,KAAK,EAAE,SAAQ;;AAGpC,YAAM,IAAI,UACR,wCAAwC,MAAM,YAAY,IAAI,mIAAmI;;AAKrM,QAAI,OAAO,gBAAgB,aAAa;AACtC,UAAI,iBAAiB,cAAc,iBAAiB,aAAa;AAC/D,aAAK,gBAAL,KAAK,cAAgB,IAAI,YAAY,MAAM;AAC3C,eAAO,KAAK,YAAY,OAAO,KAAK;;AAGtC,YAAM,IAAI,UACR,oDACG,MAAc,YAAY,IAC7B,gDAAgD;;AAIpD,UAAM,IAAI,UACR,gGAAgG;EAEpG;EAEA,QAAK;AACH,QAAI,CAAC,KAAK,OAAO,UAAU,CAAC,KAAK,YAAY;AAC3C,aAAO,CAAA;;AAGT,UAAM,QAAQ,CAAC,KAAK,OAAO,KAAK,EAAE,CAAC;AACnC,SAAK,SAAS,CAAA;AACd,SAAK,aAAa;AAClB,WAAO;EACT;;AA9FO,YAAA,gBAAgB,oBAAI,IAAI,CAAC,MAAM,MAAM,MAAQ,MAAQ,KAAQ,KAAQ,KAAQ,KAAQ,UAAU,QAAQ,CAAC;AACxG,YAAA,iBAAiB;AAgG1B,SAAS,UAAU,KAAa,WAAiB;AAC/C,QAAM,QAAQ,IAAI,QAAQ,SAAS;AACnC,MAAI,UAAU,IAAI;AAChB,WAAO,CAAC,IAAI,UAAU,GAAG,KAAK,GAAG,WAAW,IAAI,UAAU,QAAQ,UAAU,MAAM,CAAC;;AAGrF,SAAO,CAAC,KAAK,IAAI,EAAE;AACrB;AAQM,SAAU,4BAA+B,QAAW;AACxD,MAAI,OAAO,OAAO,aAAa;AAAG,WAAO;AAEzC,QAAM,SAAS,OAAO,UAAS;AAC/B,SAAO;IACL,MAAM,OAAI;AACR,UAAI;AACF,cAAM,SAAS,MAAM,OAAO,KAAI;AAChC,YAAI,iCAAQ;AAAM,iBAAO,YAAW;AACpC,eAAO;eACA,GAAG;AACV,eAAO,YAAW;AAClB,cAAM;;IAEV;IACA,MAAM,SAAM;AACV,YAAM,gBAAgB,OAAO,OAAM;AACnC,aAAO,YAAW;AAClB,YAAM;AACN,aAAO,EAAE,MAAM,MAAM,OAAO,OAAS;IACvC;IACA,CAAC,OAAO,aAAa,IAAC;AACpB,aAAO;IACT;;AAEJ;;;AC5VO,IAAM,iBAAiB,CAAC,UAC7B,SAAS,QACT,OAAO,UAAU,YACjB,OAAO,MAAM,QAAQ,YACrB,OAAO,MAAM,SAAS;AAEjB,IAAM,aAAa,CAAC,UACzB,SAAS,QACT,OAAO,UAAU,YACjB,OAAO,MAAM,SAAS,YACtB,OAAO,MAAM,iBAAiB,YAC9B,WAAW,KAAK;AAMX,IAAM,aAAa,CAAC,UACzB,SAAS,QACT,OAAO,UAAU,YACjB,OAAO,MAAM,SAAS,YACtB,OAAO,MAAM,SAAS,YACtB,OAAO,MAAM,SAAS,cACtB,OAAO,MAAM,UAAU,cACvB,OAAO,MAAM,gBAAgB;AAExB,IAAM,eAAe,CAAC,UAAmC;AAC9D,SAAO,WAAW,KAAK,KAAK,eAAe,KAAK,KAAK,eAAe,KAAK;AAC3E;AAaA,eAAsB,OACpB,OACA,MACA,SAAqC;;AAGrC,UAAQ,MAAM;AAGd,MAAI,WAAW,KAAK,GAAG;AACrB,WAAO;;AAGT,MAAI,eAAe,KAAK,GAAG;AACzB,UAAM,OAAO,MAAM,MAAM,KAAI;AAC7B,aAAA,OAAS,IAAI,IAAI,MAAM,GAAG,EAAE,SAAS,MAAM,OAAO,EAAE,IAAG,KAAM;AAK7D,UAAM,OAAO,WAAW,IAAI,IAAI,CAAE,MAAM,KAAK,YAAW,CAAU,IAAI,CAAC,IAAI;AAE3E,WAAO,IAAIC,MAAK,MAAM,MAAM,OAAO;;AAGrC,QAAM,OAAO,MAAM,SAAS,KAAK;AAEjC,WAAA,OAAS,QAAQ,KAAK,KAAK;AAE3B,MAAI,EAAC,mCAAS,OAAM;AAClB,UAAM,QAAQC,MAAA,KAAK,CAAC,MAAN,gBAAAA,IAAiB;AAC/B,QAAI,OAAO,SAAS,UAAU;AAC5B,gBAAU,EAAE,GAAG,SAAS,KAAI;;;AAIhC,SAAO,IAAID,MAAK,MAAM,MAAM,OAAO;AACrC;AAEA,eAAe,SAAS,OAAkB;;AACxC,MAAI,QAAyB,CAAA;AAC7B,MACE,OAAO,UAAU,YACjB,YAAY,OAAO,KAAK;EACxB,iBAAiB,aACjB;AACA,UAAM,KAAK,KAAK;aACP,WAAW,KAAK,GAAG;AAC5B,UAAM,KAAK,MAAM,MAAM,YAAW,CAAE;aAEpC,wBAAwB,KAAK,GAC7B;AACA,qBAAiB,SAAS,OAAO;AAC/B,YAAM,KAAK,KAAiB;;SAEzB;AACL,UAAM,IAAI,MACR,yBAAyB,OAAO,KAAK,mBAAkBC,MAAA,+BAAO,gBAAP,gBAAAA,IACnD,IAAI,YAAY,cAAc,KAAK,CAAC,EAAE;;AAI9C,SAAO;AACT;AAEA,SAAS,cAAc,OAAU;AAC/B,QAAM,QAAQ,OAAO,oBAAoB,KAAK;AAC9C,SAAO,IAAI,MAAM,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EAAE,KAAK,IAAI,CAAC;AAClD;AAEA,SAAS,QAAQ,OAAU;;AACzB,SACE,yBAAyB,MAAM,IAAI,KACnC,yBAAyB,MAAM,QAAQ;IAEvCA,MAAA,yBAAyB,MAAM,IAAI,MAAnC,gBAAAA,IAAsC,MAAM,SAAS;AAEzD;AAEA,IAAM,2BAA2B,CAAC,MAAoD;AACpF,MAAI,OAAO,MAAM;AAAU,WAAO;AAClC,MAAI,OAAO,WAAW,eAAe,aAAa;AAAQ,WAAO,OAAO,CAAC;AACzE,SAAO;AACT;AAEA,IAAM,0BAA0B,CAAC,UAC/B,SAAS,QAAQ,OAAO,UAAU,YAAY,OAAO,MAAM,OAAO,aAAa,MAAM;AAEhF,IAAM,kBAAkB,CAAC,SAC9B,QAAQ,OAAO,SAAS,YAAY,KAAK,QAAQ,KAAK,OAAO,WAAW,MAAM;AAezE,IAAM,8BAA8B,OACzC,SAC8C;AAC9C,QAAM,OAAO,MAAM,WAAW,KAAK,IAAI;AACvC,SAAO,2BAA2B,MAAM,IAAI;AAC9C;AAEO,IAAM,aAAa,OAAoC,SAA0C;AACtG,QAAM,OAAO,IAAIC,UAAQ;AACzB,QAAM,QAAQ,IAAI,OAAO,QAAQ,QAAQ,CAAA,CAAE,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM,aAAa,MAAM,KAAK,KAAK,CAAC,CAAC;AAClG,SAAO;AACT;AAaA,IAAM,eAAe,OAAO,MAAgB,KAAa,UAAiC;AACxF,MAAI,UAAU;AAAW;AACzB,MAAI,SAAS,MAAM;AACjB,UAAM,IAAI,UACR,sBAAsB,GAAG,6DAA6D;;AAK1F,MAAI,OAAO,UAAU,YAAY,OAAO,UAAU,YAAY,OAAO,UAAU,WAAW;AACxF,SAAK,OAAO,KAAK,OAAO,KAAK,CAAC;aACrB,aAAa,KAAK,GAAG;AAC9B,UAAM,OAAO,MAAM,OAAO,KAAK;AAC/B,SAAK,OAAO,KAAK,IAAY;aACpB,MAAM,QAAQ,KAAK,GAAG;AAC/B,UAAM,QAAQ,IAAI,MAAM,IAAI,CAAC,UAAU,aAAa,MAAM,MAAM,MAAM,KAAK,CAAC,CAAC;aACpE,OAAO,UAAU,UAAU;AACpC,UAAM,QAAQ,IACZ,OAAO,QAAQ,KAAK,EAAE,IAAI,CAAC,CAAC,MAAM,IAAI,MAAM,aAAa,MAAM,GAAG,GAAG,IAAI,IAAI,KAAK,IAAI,CAAC,CAAC;SAErF;AACL,UAAM,IAAI,UACR,wGAAwG,KAAK,UAAU;;AAG7H;;;;;;;;;;;;;;;;;;;;ACvNA,eAAe,qBAAwB,OAAuB;AAC5D,QAAM,EAAE,SAAQ,IAAK;AACrB,MAAI,MAAM,QAAQ,QAAQ;AACxB,UAAM,YAAY,SAAS,QAAQ,SAAS,KAAK,SAAS,SAAS,SAAS,IAAI;AAKhF,QAAI,MAAM,QAAQ,eAAe;AAC/B,aAAO,MAAM,QAAQ,cAAc,gBAAgB,UAAU,MAAM,UAAU;;AAG/E,WAAO,OAAO,gBAAgB,UAAU,MAAM,UAAU;;AAI1D,MAAI,SAAS,WAAW,KAAK;AAC3B,WAAO;;AAGT,MAAI,MAAM,QAAQ,kBAAkB;AAClC,WAAO;;AAGT,QAAM,cAAc,SAAS,QAAQ,IAAI,cAAc;AACvD,QAAM,UACJ,2CAAa,SAAS,yBAAuB,2CAAa,SAAS;AACrE,MAAI,QAAQ;AACV,UAAM,OAAO,MAAM,SAAS,KAAI;AAEhC,UAAM,YAAY,SAAS,QAAQ,SAAS,KAAK,SAAS,SAAS,IAAI;AAEvE,WAAO;;AAGT,QAAM,OAAO,MAAM,SAAS,KAAI;AAChC,QAAM,YAAY,SAAS,QAAQ,SAAS,KAAK,SAAS,SAAS,IAAI;AAGvE,SAAO;AACT;AAMM,IAAO,aAAP,MAAO,oBAAsB,QAAU;EAG3C,YACU,iBACA,gBAAgE,sBAAoB;AAE5F,UAAM,CAAC,YAAW;AAIhB,cAAQ,IAAW;IACrB,CAAC;AARO,SAAA,kBAAA;AACA,SAAA,gBAAA;EAQV;EAEA,YAAe,WAAkD;AAC/D,WAAO,IAAI,YAAW,KAAK,iBAAiB,OAAO,UACjD,UAAU,MAAM,KAAK,cAAc,KAAK,GAAG,KAAK,CAAC;EAErD;;;;;;;;;;;;;;EAeA,aAAU;AACR,WAAO,KAAK,gBAAgB,KAAK,CAAC,MAAM,EAAE,QAAQ;EACpD;;;;;;;;;;;;;;EAcA,MAAM,eAAY;AAChB,UAAM,CAAC,MAAM,QAAQ,IAAI,MAAM,QAAQ,IAAI,CAAC,KAAK,MAAK,GAAI,KAAK,WAAU,CAAE,CAAC;AAC5E,WAAO,EAAE,MAAM,SAAQ;EACzB;EAEQ,QAAK;AACX,QAAI,CAAC,KAAK,eAAe;AACvB,WAAK,gBAAgB,KAAK,gBAAgB,KAAK,KAAK,aAAa;;AAEnE,WAAO,KAAK;EACd;EAES,KACP,aACA,YAAmF;AAEnF,WAAO,KAAK,MAAK,EAAG,KAAK,aAAa,UAAU;EAClD;EAES,MACP,YAAiF;AAEjF,WAAO,KAAK,MAAK,EAAG,MAAM,UAAU;EACtC;EAES,QAAQ,WAA2C;AAC1D,WAAO,KAAK,MAAK,EAAG,QAAQ,SAAS;EACvC;;AAGI,IAAgB,YAAhB,MAAyB;EAS7B,YAAY;IACV;IACA,aAAa;IACb,UAAU;;IACV;IACA,OAAO;EAAe,GAOvB;AACC,SAAK,UAAU;AACf,SAAK,aAAa,wBAAwB,cAAc,UAAU;AAClE,SAAK,UAAU,wBAAwB,WAAW,OAAO;AACzD,SAAK,YAAY;AAEjB,SAAK,QAAQ,mBAAmBC;EAClC;EAEU,YAAY,MAAyB;AAC7C,WAAO,CAAA;EACT;;;;;;;;;EAUU,eAAe,MAAyB;AAChD,WAAO;MACL,QAAQ;MACR,gBAAgB;MAChB,cAAc,KAAK,aAAY;MAC/B,GAAG,mBAAkB;MACrB,GAAG,KAAK,YAAY,IAAI;;EAE5B;;;;EAOU,gBAAgB,SAAkB,eAAsB;EAAG;EAE3D,wBAAqB;AAC7B,WAAO,wBAAwB,MAAK,CAAE;EACxC;EAEA,IAAc,MAAc,MAA0C;AACpE,WAAO,KAAK,cAAc,OAAO,MAAM,IAAI;EAC7C;EAEA,KAAe,MAAc,MAA0C;AACrE,WAAO,KAAK,cAAc,QAAQ,MAAM,IAAI;EAC9C;EAEA,MAAgB,MAAc,MAA0C;AACtE,WAAO,KAAK,cAAc,SAAS,MAAM,IAAI;EAC/C;EAEA,IAAc,MAAc,MAA0C;AACpE,WAAO,KAAK,cAAc,OAAO,MAAM,IAAI;EAC7C;EAEA,OAAiB,MAAc,MAA0C;AACvE,WAAO,KAAK,cAAc,UAAU,MAAM,IAAI;EAChD;EAEQ,cACN,QACA,MACA,MAA0C;AAE1C,WAAO,KAAK,QACV,QAAQ,QAAQ,IAAI,EAAE,KAAK,OAAOC,UAAQ;AACxC,YAAM,OACJA,SAAQ,WAAWA,SAAA,gBAAAA,MAAM,IAAI,IAAI,IAAI,SAAS,MAAMA,MAAK,KAAK,YAAW,CAAE,KACzEA,SAAA,gBAAAA,MAAM,iBAAgB,WAAWA,MAAK,QACtCA,SAAA,gBAAAA,MAAM,iBAAgB,cAAc,IAAI,SAASA,MAAK,IAAI,IAC1DA,SAAQ,YAAY,OAAOA,SAAA,gBAAAA,MAAM,IAAI,IAAI,IAAI,SAASA,MAAK,KAAK,MAAM,IACtEA,SAAA,gBAAAA,MAAM;AACV,aAAO,EAAE,QAAQ,MAAM,GAAGA,OAAM,KAAI;IACtC,CAAC,CAAC;EAEN;EAEA,WACE,MACA,MACA,MAA0B;AAE1B,WAAO,KAAK,eAAe,MAAM,EAAE,QAAQ,OAAO,MAAM,GAAG,KAAI,CAAE;EACnE;EAEQ,uBAAuB,MAAa;AAC1C,QAAI,OAAO,SAAS,UAAU;AAC5B,UAAI,OAAO,WAAW,aAAa;AACjC,eAAO,OAAO,WAAW,MAAM,MAAM,EAAE,SAAQ;;AAGjD,UAAI,OAAO,gBAAgB,aAAa;AACtC,cAAM,UAAU,IAAI,YAAW;AAC/B,cAAM,UAAU,QAAQ,OAAO,IAAI;AACnC,eAAO,QAAQ,OAAO,SAAQ;;eAEvB,YAAY,OAAO,IAAI,GAAG;AACnC,aAAO,KAAK,WAAW,SAAQ;;AAGjC,WAAO;EACT;EAEA,aACE,SACA,EAAE,aAAa,EAAC,IAA8B,CAAA,GAAE;;AAEhD,UAAM,EAAE,QAAQ,MAAM,OAAO,UAAmB,CAAA,EAAE,IAAK;AAEvD,UAAM,OACJ,YAAY,OAAO,QAAQ,IAAI,KAAM,QAAQ,mBAAmB,OAAO,QAAQ,SAAS,WACtF,QAAQ,OACR,gBAAgB,QAAQ,IAAI,IAAI,QAAQ,KAAK,OAC7C,QAAQ,OAAO,KAAK,UAAU,QAAQ,MAAM,MAAM,CAAC,IACnD;AACJ,UAAM,gBAAgB,KAAK,uBAAuB,IAAI;AAEtD,UAAM,MAAM,KAAK,SAAS,MAAO,KAAK;AACtC,QAAI,aAAa;AAAS,8BAAwB,WAAW,QAAQ,OAAO;AAC5E,UAAM,UAAU,QAAQ,WAAW,KAAK;AACxC,UAAM,YAAY,QAAQ,aAAa,KAAK,aAAa,gBAAgB,GAAG;AAC5E,UAAM,kBAAkB,UAAU;AAClC,QACE,SAAQC,MAAA,uCAAmB,YAAnB,gBAAAA,IAA4B,aAAY,YAChD,mBAAoB,UAAkB,QAAQ,WAAW,IACzD;AAKC,gBAAkB,QAAQ,UAAU;;AAGvC,QAAI,KAAK,qBAAqB,WAAW,OAAO;AAC9C,UAAI,CAAC,QAAQ;AAAgB,gBAAQ,iBAAiB,KAAK,sBAAqB;AAChF,cAAQ,KAAK,iBAAiB,IAAI,QAAQ;;AAG5C,UAAM,aAAa,KAAK,aAAa,EAAE,SAAS,SAAS,eAAe,WAAU,CAAE;AAEpF,UAAM,MAAmB;MACvB;MACA,GAAI,QAAQ,EAAE,KAAiB;MAC/B,SAAS;MACT,GAAI,aAAa,EAAE,OAAO,UAAS;;;MAGnC,QAAQ,QAAQ,UAAU;;AAG5B,WAAO,EAAE,KAAK,KAAK,QAAO;EAC5B;EAEQ,aAAa,EACnB,SACA,SACA,eACA,WAAU,GAMX;AACC,UAAM,aAAqC,CAAA;AAC3C,QAAI,eAAe;AACjB,iBAAW,gBAAgB,IAAI;;AAGjC,UAAM,iBAAiB,KAAK,eAAe,OAAO;AAClD,oBAAgB,YAAY,cAAc;AAC1C,oBAAgB,YAAY,OAAO;AAGnC,QAAI,gBAAgB,QAAQ,IAAI,KAAK,SAAc,QAAQ;AACzD,aAAO,WAAW,cAAc;;AAMlC,QACE,UAAU,gBAAgB,yBAAyB,MAAM,UACzD,UAAU,SAAS,yBAAyB,MAAM,QAClD;AACA,iBAAW,yBAAyB,IAAI,OAAO,UAAU;;AAG3D,SAAK,gBAAgB,YAAY,OAAO;AAExC,WAAO;EACT;;;;EAKU,MAAM,eAAe,SAA4B;EAAkB;;;;;;;EAQnE,MAAM,eACd,SACA,EAAE,KAAK,QAAO,GAAiD;EAC/C;EAER,aAAa,SAAuC;AAC5D,WACE,CAAC,UAAU,CAAA,IACT,OAAO,YAAY,UACnB,OAAO,YAAY,MAAM,KAAK,OAA6B,EAAE,IAAI,CAAC,WAAW,CAAC,GAAG,MAAM,CAAC,CAAC,IACzF,EAAE,GAAG,QAAO;EAElB;EAEU,gBACR,QACA,OACA,SACA,SAA4B;AAE5B,WAAO,SAAS,SAAS,QAAQ,OAAO,SAAS,OAAO;EAC1D;EAEA,QACE,SACA,mBAAkC,MAAI;AAEtC,WAAO,IAAI,WAAW,KAAK,YAAY,SAAS,gBAAgB,CAAC;EACnE;EAEQ,MAAM,YACZ,cACA,kBAA+B;;AAE/B,UAAM,UAAU,MAAM;AACtB,UAAM,aAAa,QAAQ,cAAc,KAAK;AAC9C,QAAI,oBAAoB,MAAM;AAC5B,yBAAmB;;AAGrB,UAAM,KAAK,eAAe,OAAO;AAEjC,UAAM,EAAE,KAAK,KAAK,QAAO,IAAK,KAAK,aAAa,SAAS,EAAE,YAAY,aAAa,iBAAgB,CAAE;AAEtG,UAAM,KAAK,eAAe,KAAK,EAAE,KAAK,QAAO,CAAE;AAE/C,UAAM,WAAW,KAAK,SAAS,IAAI,OAAO;AAE1C,SAAIA,MAAA,QAAQ,WAAR,gBAAAA,IAAgB,SAAS;AAC3B,YAAM,IAAI,kBAAiB;;AAG7B,UAAM,aAAa,IAAI,gBAAe;AACtC,UAAM,WAAW,MAAM,KAAK,iBAAiB,KAAK,KAAK,SAAS,UAAU,EAAE,MAAM,WAAW;AAE7F,QAAI,oBAAoB,OAAO;AAC7B,WAAI,aAAQ,WAAR,mBAAgB,SAAS;AAC3B,cAAM,IAAI,kBAAiB;;AAE7B,UAAI,kBAAkB;AACpB,eAAO,KAAK,aAAa,SAAS,gBAAgB;;AAEpD,UAAI,SAAS,SAAS,cAAc;AAClC,cAAM,IAAI,0BAAyB;;AAErC,YAAM,IAAI,mBAAmB,EAAE,OAAO,SAAQ,CAAE;;AAGlD,UAAM,kBAAkB,sBAAsB,SAAS,OAAO;AAE9D,QAAI,CAAC,SAAS,IAAI;AAChB,UAAI,oBAAoB,KAAK,YAAY,QAAQ,GAAG;AAClD,cAAMC,gBAAe,aAAa,gBAAgB;AAClD,cAAM,oBAAoBA,aAAY,KAAK,SAAS,QAAQ,KAAK,eAAe;AAChF,eAAO,KAAK,aAAa,SAAS,kBAAkB,eAAe;;AAGrE,YAAM,UAAU,MAAM,SAAS,KAAI,EAAG,MAAM,CAAC,MAAM,YAAY,CAAC,EAAE,OAAO;AACzE,YAAM,UAAU,SAAS,OAAO;AAChC,YAAM,aAAa,UAAU,SAAY;AACzC,YAAM,eAAe,mBAAmB,kCAAkC;AAE1E,YAAM,oBAAoB,YAAY,KAAK,SAAS,QAAQ,KAAK,iBAAiB,UAAU;AAE5F,YAAM,MAAM,KAAK,gBAAgB,SAAS,QAAQ,SAAS,YAAY,eAAe;AACtF,YAAM;;AAGR,WAAO,EAAE,UAAU,SAAS,WAAU;EACxC;EAEA,eACE,MACA,SAA4B;AAE5B,UAAM,UAAU,KAAK,YAAY,SAAS,IAAI;AAC9C,WAAO,IAAI,YAA6B,MAAM,SAAS,IAAI;EAC7D;EAEA,SAAc,MAAc,OAA6B;AACvD,UAAM,MACJ,cAAc,IAAI,IAChB,IAAI,IAAI,IAAI,IACZ,IAAI,IAAI,KAAK,WAAW,KAAK,QAAQ,SAAS,GAAG,KAAK,KAAK,WAAW,GAAG,IAAI,KAAK,MAAM,CAAC,IAAI,KAAK;AAEtG,UAAM,eAAe,KAAK,aAAY;AACtC,QAAI,CAAC,WAAW,YAAY,GAAG;AAC7B,cAAQ,EAAE,GAAG,cAAc,GAAG,MAAK;;AAGrC,QAAI,OAAO,UAAU,YAAY,SAAS,CAAC,MAAM,QAAQ,KAAK,GAAG;AAC/D,UAAI,SAAS,KAAK,eAAe,KAAgC;;AAGnE,WAAO,IAAI,SAAQ;EACrB;EAEU,eAAe,OAA8B;AACrD,WAAO,OAAO,QAAQ,KAAK,EACxB,OAAO,CAAC,CAAC,GAAG,KAAK,MAAM,OAAO,UAAU,WAAW,EACnD,IAAI,CAAC,CAAC,KAAK,KAAK,MAAK;AACpB,UAAI,OAAO,UAAU,YAAY,OAAO,UAAU,YAAY,OAAO,UAAU,WAAW;AACxF,eAAO,GAAG,mBAAmB,GAAG,CAAC,IAAI,mBAAmB,KAAK,CAAC;;AAEhE,UAAI,UAAU,MAAM;AAClB,eAAO,GAAG,mBAAmB,GAAG,CAAC;;AAEnC,YAAM,IAAI,UACR,yBAAyB,OAAO,KAAK,mQAAmQ;IAE5S,CAAC,EACA,KAAK,GAAG;EACb;EAEA,MAAM,iBACJ,KACA,MACA,IACA,YAA2B;AAE3B,UAAM,EAAE,QAAQ,GAAG,QAAO,IAAK,QAAQ,CAAA;AACvC,QAAI;AAAQ,aAAO,iBAAiB,SAAS,MAAM,WAAW,MAAK,CAAE;AAErE,UAAM,UAAU,WAAW,MAAM,WAAW,MAAK,GAAI,EAAE;AAEvD,UAAM,eAAe;MACnB,QAAQ,WAAW;MACnB,GAAG;;AAEL,QAAI,aAAa,QAAQ;AAGvB,mBAAa,SAAS,aAAa,OAAO,YAAW;;AAGvD;;MAEE,KAAK,MAAM,KAAK,QAAW,KAAK,YAAY,EAAE,QAAQ,MAAK;AACzD,qBAAa,OAAO;MACtB,CAAC;;EAEL;EAEQ,YAAY,UAAkB;AAEpC,UAAM,oBAAoB,SAAS,QAAQ,IAAI,gBAAgB;AAG/D,QAAI,sBAAsB;AAAQ,aAAO;AACzC,QAAI,sBAAsB;AAAS,aAAO;AAG1C,QAAI,SAAS,WAAW;AAAK,aAAO;AAGpC,QAAI,SAAS,WAAW;AAAK,aAAO;AAGpC,QAAI,SAAS,WAAW;AAAK,aAAO;AAGpC,QAAI,SAAS,UAAU;AAAK,aAAO;AAEnC,WAAO;EACT;EAEQ,MAAM,aACZ,SACA,kBACA,iBAAqC;AAErC,QAAI;AAGJ,UAAM,yBAAyB,mDAAkB;AACjD,QAAI,wBAAwB;AAC1B,YAAM,YAAY,WAAW,sBAAsB;AACnD,UAAI,CAAC,OAAO,MAAM,SAAS,GAAG;AAC5B,wBAAgB;;;AAKpB,UAAM,mBAAmB,mDAAkB;AAC3C,QAAI,oBAAoB,CAAC,eAAe;AACtC,YAAM,iBAAiB,WAAW,gBAAgB;AAClD,UAAI,CAAC,OAAO,MAAM,cAAc,GAAG;AACjC,wBAAgB,iBAAiB;aAC5B;AACL,wBAAgB,KAAK,MAAM,gBAAgB,IAAI,KAAK,IAAG;;;AAM3D,QAAI,EAAE,iBAAiB,KAAK,iBAAiB,gBAAgB,KAAK,MAAO;AACvE,YAAM,aAAa,QAAQ,cAAc,KAAK;AAC9C,sBAAgB,KAAK,mCAAmC,kBAAkB,UAAU;;AAEtF,UAAM,MAAM,aAAa;AAEzB,WAAO,KAAK,YAAY,SAAS,mBAAmB,CAAC;EACvD;EAEQ,mCAAmC,kBAA0B,YAAkB;AACrF,UAAM,oBAAoB;AAC1B,UAAM,gBAAgB;AAEtB,UAAM,aAAa,aAAa;AAGhC,UAAM,eAAe,KAAK,IAAI,oBAAoB,KAAK,IAAI,GAAG,UAAU,GAAG,aAAa;AAGxF,UAAM,SAAS,IAAI,KAAK,OAAM,IAAK;AAEnC,WAAO,eAAe,SAAS;EACjC;EAEQ,eAAY;AAClB,WAAO,GAAG,KAAK,YAAY,IAAI,OAAO,OAAO;EAC/C;;AAKI,IAAgB,eAAhB,MAA4B;EAOhC,YAAY,QAAmB,UAAoB,MAAe,SAA4B;AAN9F,yBAAA,IAAA,MAAA,MAAA;AAOE,2BAAA,MAAI,sBAAW,QAAM,GAAA;AACrB,SAAK,UAAU;AACf,SAAK,WAAW;AAChB,SAAK,OAAO;EACd;EAUA,cAAW;AACT,UAAM,QAAQ,KAAK,kBAAiB;AACpC,QAAI,CAAC,MAAM;AAAQ,aAAO;AAC1B,WAAO,KAAK,aAAY,KAAM;EAChC;EAEA,MAAM,cAAW;AACf,UAAM,WAAW,KAAK,aAAY;AAClC,QAAI,CAAC,UAAU;AACb,YAAM,IAAI,UACR,uFAAuF;;AAG3F,UAAM,cAAc,EAAE,GAAG,KAAK,QAAO;AACrC,QAAI,YAAY,YAAY,OAAO,YAAY,UAAU,UAAU;AACjE,kBAAY,QAAQ,EAAE,GAAG,YAAY,OAAO,GAAG,SAAS,OAAM;eACrD,SAAS,UAAU;AAC5B,YAAM,SAAS,CAAC,GAAG,OAAO,QAAQ,YAAY,SAAS,CAAA,CAAE,GAAG,GAAG,SAAS,IAAI,aAAa,QAAO,CAAE;AAClG,iBAAW,CAAC,KAAK,KAAK,KAAK,QAAQ;AACjC,iBAAS,IAAI,aAAa,IAAI,KAAK,KAAY;;AAEjD,kBAAY,QAAQ;AACpB,kBAAY,OAAO,SAAS,IAAI,SAAQ;;AAE1C,WAAO,MAAM,uBAAA,MAAI,sBAAA,GAAA,EAAS,eAAe,KAAK,aAAoB,WAAW;EAC/E;EAEA,OAAO,YAAS;AAEd,QAAI,OAAa;AACjB,UAAM;AACN,WAAO,KAAK,YAAW,GAAI;AACzB,aAAO,MAAM,KAAK,YAAW;AAC7B,YAAM;;EAEV;EAEA,SAAO,uBAAA,oBAAA,QAAA,GAAC,OAAO,cAAa,IAAC;AAC3B,qBAAiB,QAAQ,KAAK,UAAS,GAAI;AACzC,iBAAW,QAAQ,KAAK,kBAAiB,GAAI;AAC3C,cAAM;;;EAGZ;;AAYI,IAAO,cAAP,cAII,WAAqB;EAG7B,YACE,QACA,SACA,MAA4E;AAE5E,UACE,SACA,OAAO,UAAU,IAAI,KAAK,QAAQ,MAAM,UAAU,MAAM,qBAAqB,KAAK,GAAG,MAAM,OAAO,CAAC;EAEvG;;;;;;;;EASA,QAAQ,OAAO,aAAa,IAAC;AAC3B,UAAM,OAAO,MAAM;AACnB,qBAAiB,QAAQ,MAAM;AAC7B,YAAM;;EAEV;;AAGK,IAAM,wBAAwB,CACnC,YAC0B;AAC1B,SAAO,IAAI,MACT,OAAO;;IAEL,QAAQ,QAAO;EAAE,GAEnB;IACE,IAAI,QAAQ,MAAI;AACd,YAAM,MAAM,KAAK,SAAQ;AACzB,aAAO,OAAO,IAAI,YAAW,CAAE,KAAK,OAAO,GAAG;IAChD;GACD;AAEL;AAyFA,IAAM,wBAAwB,MAAyB;;AACrD,MAAI,OAAO,SAAS,eAAe,KAAK,SAAS,MAAM;AACrD,WAAO;MACL,oBAAoB;MACpB,+BAA+B;MAC/B,kBAAkB,kBAAkB,KAAK,MAAM,EAAE;MACjD,oBAAoB,cAAc,KAAK,MAAM,IAAI;MACjD,uBAAuB;MACvB,+BACE,OAAO,KAAK,YAAY,WAAW,KAAK,YAAUC,MAAA,KAAK,YAAL,gBAAAA,IAAc,SAAQ;;;AAG9E,MAAI,OAAO,gBAAgB,aAAa;AACtC,WAAO;MACL,oBAAoB;MACpB,+BAA+B;MAC/B,kBAAkB;MAClB,oBAAoB,SAAS,WAAW;MACxC,uBAAuB;MACvB,+BAA+B,QAAQ;;;AAI3C,MAAI,OAAO,UAAU,SAAS,KAAK,OAAO,YAAY,cAAc,UAAU,CAAC,MAAM,oBAAoB;AACvG,WAAO;MACL,oBAAoB;MACpB,+BAA+B;MAC/B,kBAAkB,kBAAkB,QAAQ,QAAQ;MACpD,oBAAoB,cAAc,QAAQ,IAAI;MAC9C,uBAAuB;MACvB,+BAA+B,QAAQ;;;AAI3C,QAAM,cAAc,eAAc;AAClC,MAAI,aAAa;AACf,WAAO;MACL,oBAAoB;MACpB,+BAA+B;MAC/B,kBAAkB;MAClB,oBAAoB;MACpB,uBAAuB,WAAW,YAAY,OAAO;MACrD,+BAA+B,YAAY;;;AAK/C,SAAO;IACL,oBAAoB;IACpB,+BAA+B;IAC/B,kBAAkB;IAClB,oBAAoB;IACpB,uBAAuB;IACvB,+BAA+B;;AAEnC;AAUA,SAAS,iBAAc;AACrB,MAAI,OAAO,cAAc,eAAe,CAAC,WAAW;AAClD,WAAO;;AAIT,QAAM,kBAAkB;IACtB,EAAE,KAAK,QAAiB,SAAS,uCAAsC;IACvE,EAAE,KAAK,MAAe,SAAS,uCAAsC;IACrE,EAAE,KAAK,MAAe,SAAS,6CAA4C;IAC3E,EAAE,KAAK,UAAmB,SAAS,yCAAwC;IAC3E,EAAE,KAAK,WAAoB,SAAS,0CAAyC;IAC7E,EAAE,KAAK,UAAmB,SAAS,oEAAmE;;AAIxG,aAAW,EAAE,KAAK,QAAO,KAAM,iBAAiB;AAC9C,UAAM,QAAQ,QAAQ,KAAK,UAAU,SAAS;AAC9C,QAAI,OAAO;AACT,YAAM,QAAQ,MAAM,CAAC,KAAK;AAC1B,YAAM,QAAQ,MAAM,CAAC,KAAK;AAC1B,YAAM,QAAQ,MAAM,CAAC,KAAK;AAE1B,aAAO,EAAE,SAAS,KAAK,SAAS,GAAG,KAAK,IAAI,KAAK,IAAI,KAAK,GAAE;;;AAIhE,SAAO;AACT;AAEA,IAAM,gBAAgB,CAAC,SAAsB;AAK3C,MAAI,SAAS;AAAO,WAAO;AAC3B,MAAI,SAAS,YAAY,SAAS;AAAO,WAAO;AAChD,MAAI,SAAS;AAAO,WAAO;AAC3B,MAAI,SAAS,aAAa,SAAS;AAAS,WAAO;AACnD,MAAI;AAAM,WAAO,SAAS,IAAI;AAC9B,SAAO;AACT;AAEA,IAAM,oBAAoB,CAAC,aAAkC;AAO3D,aAAW,SAAS,YAAW;AAM/B,MAAI,SAAS,SAAS,KAAK;AAAG,WAAO;AACrC,MAAI,aAAa;AAAW,WAAO;AACnC,MAAI,aAAa;AAAU,WAAO;AAClC,MAAI,aAAa;AAAS,WAAO;AACjC,MAAI,aAAa;AAAW,WAAO;AACnC,MAAI,aAAa;AAAW,WAAO;AACnC,MAAI,aAAa;AAAS,WAAO;AACjC,MAAI;AAAU,WAAO,SAAS,QAAQ;AACtC,SAAO;AACT;AAEA,IAAI;AACJ,IAAM,qBAAqB,MAAK;AAC9B,SAAQ,qBAAA,mBAAqB,sBAAqB;AACpD;AAEO,IAAM,WAAW,CAAC,SAAgB;AACvC,MAAI;AACF,WAAO,KAAK,MAAM,IAAI;WACf,KAAK;AACZ,WAAO;;AAEX;AAGA,IAAM,yBAAyB;AAC/B,IAAM,gBAAgB,CAAC,QAAwB;AAC7C,SAAO,uBAAuB,KAAK,GAAG;AACxC;AAEO,IAAM,QAAQ,CAAC,OAAe,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,EAAE,CAAC;AAErF,IAAM,0BAA0B,CAAC,MAAc,MAAsB;AACnE,MAAI,OAAO,MAAM,YAAY,CAAC,OAAO,UAAU,CAAC,GAAG;AACjD,UAAM,IAAI,UAAU,GAAG,IAAI,qBAAqB;;AAElD,MAAI,IAAI,GAAG;AACT,UAAM,IAAI,UAAU,GAAG,IAAI,6BAA6B;;AAE1D,SAAO;AACT;AAEO,IAAM,cAAc,CAAC,QAAmB;AAC7C,MAAI,eAAe;AAAO,WAAO;AACjC,MAAI,OAAO,QAAQ,YAAY,QAAQ,MAAM;AAC3C,QAAI;AACF,aAAO,IAAI,MAAM,KAAK,UAAU,GAAG,CAAC;YAC9B;IAAA;;AAEV,SAAO,IAAI,MAAM,GAAG;AACtB;AAcO,IAAM,UAAU,CAAC,QAAmC;;AACzD,MAAI,OAAO,YAAY,aAAa;AAClC,aAAO,MAAAC,MAAA,QAAQ,QAAR,gBAAAA,IAAc,SAAd,mBAAoB,WAAU;;AAEvC,MAAI,OAAO,SAAS,aAAa;AAC/B,YAAO,sBAAK,QAAL,mBAAU,QAAV,4BAAgB,SAAhB,mBAAsB;;AAE/B,SAAO;AACT;AA4CM,SAAU,WAAW,KAA8B;AACvD,MAAI,CAAC;AAAK,WAAO;AACjB,aAAW,MAAM;AAAK,WAAO;AAC7B,SAAO;AACT;AAGM,SAAU,OAAO,KAAa,KAAW;AAC7C,SAAO,OAAO,UAAU,eAAe,KAAK,KAAK,GAAG;AACtD;AAQA,SAAS,gBAAgB,eAAwB,YAAmB;AAClE,aAAW,KAAK,YAAY;AAC1B,QAAI,CAAC,OAAO,YAAY,CAAC;AAAG;AAC5B,UAAM,WAAW,EAAE,YAAW;AAC9B,QAAI,CAAC;AAAU;AAEf,UAAM,MAAM,WAAW,CAAC;AAExB,QAAI,QAAQ,MAAM;AAChB,aAAO,cAAc,QAAQ;eACpB,QAAQ,QAAW;AAC5B,oBAAc,QAAQ,IAAI;;;AAGhC;AAEM,SAAU,MAAM,WAAmB,MAAW;;AAClD,MAAI,OAAO,YAAY,iBAAeC,MAAA,mCAAS,QAAT,gBAAAA,IAAe,cAAa,QAAQ;AACxE,YAAQ,IAAI,cAAc,MAAM,IAAI,GAAG,IAAI;;AAE/C;AAKA,IAAM,QAAQ,MAAK;AACjB,SAAO,uCAAuC,QAAQ,SAAS,CAAC,MAAK;AACnE,UAAM,IAAK,KAAK,OAAM,IAAK,KAAM;AACjC,UAAM,IAAI,MAAM,MAAM,IAAK,IAAI,IAAO;AACtC,WAAO,EAAE,SAAS,EAAE;EACtB,CAAC;AACH;AAEO,IAAM,qBAAqB,MAAK;AACrC;;IAEE,OAAO,WAAW;IAElB,OAAO,OAAO,aAAa;IAE3B,OAAO,cAAc;;AAEzB;AAOO,IAAM,oBAAoB,CAAC,YAA4C;AAC5E,SAAO,QAAO,mCAAS,SAAQ;AACjC;AAUO,IAAM,YAAY,CAAC,SAAgC,WAAsC;;AAC9F,QAAM,mBAAmB,OAAO,YAAW;AAC3C,MAAI,kBAAkB,OAAO,GAAG;AAE9B,UAAM,oBACJC,MAAA,OAAO,CAAC,MAAR,gBAAAA,IAAW,iBACX,OAAO,UAAU,CAAC,EAAE,QAAQ,gBAAgB,CAAC,IAAI,IAAI,OAAO,KAAK,GAAG,YAAW,CAAE;AACnF,eAAW,OAAO,CAAC,QAAQ,kBAAkB,OAAO,YAAW,GAAI,eAAe,GAAG;AACnF,YAAM,QAAQ,QAAQ,IAAI,GAAG;AAC7B,UAAI,OAAO;AACT,eAAO;;;;AAKb,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,OAAO,GAAG;AAClD,QAAI,IAAI,YAAW,MAAO,kBAAkB;AAC1C,UAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,YAAI,MAAM,UAAU;AAAG,iBAAO,MAAM,CAAC;AACrC,gBAAQ,KAAK,YAAY,MAAM,MAAM,oBAAoB,MAAM,iCAAiC;AAChG,eAAO,MAAM,CAAC;;AAEhB,aAAO;;;AAIX,SAAO;AACT;;;ACvqCM,IAAO,cAAP,MAAkB;EAGtB,YAAY,QAAY;AACtB,SAAK,UAAU;EACjB;;;;ACJI,IAAO,iBAAP,cAA8B,YAAW;;;;EAI7C,OAAO,MAAiC,SAA6B;AACnE,WAAO,KAAK,QAAQ,KAClB,mCACK,4BAA4B,EAAE,MAAM,GAAG,QAAO,CAAE,CAAC;EAE1D;;;;ACTI,IAAO,eAAP,cAA4B,YAAW;;;;EAI3C,OAAO,MAA+B,SAA6B;AACjE,WAAO,KAAK,QAAQ,KAClB,iCACK,4BAA4B,EAAE,MAAM,GAAG,QAAO,CAAE,CAAC;EAE1D;;;;ACNI,IAAO,QAAP,cAAqB,YAAW;EAAtC,cAAA;;AACE,SAAA,iBAAmD,IAAsB,eAAe,KAAK,OAAO;AACpG,SAAA,eAA6C,IAAoB,aAAa,KAAK,OAAO;EAC5F;;AAEA,MAAM,iBAAiB;AACvB,MAAM,eAAe;;;ACTf,IAAO,UAAP,cAAuB,YAAW;;;;EAItC,OAAO,MAAyB,SAA6B;AAC3D,WAAO,KAAK,QAAQ,KAAK,sBAAsB,EAAE,MAAM,GAAG,QAAO,CAAE;EACrE;;;;EAKA,SAAS,SAAiB,SAA6B;AACrD,WAAO,KAAK,QAAQ,IAAI,sBAAsB,OAAO,IAAI,OAAO;EAClE;;;;EAKA,KAAK,SAA6B;AAChC,WAAO,KAAK,QAAQ,IAAI,sBAAsB,OAAO;EACvD;;;;AChBI,IAAO,cAAP,cAA2B,YAAW;EAgB1C,OACE,MACA,SAA6B;AAE7B,WAAO,KAAK,QAAQ,KAAK,+BAA+B;MACtD;MACA,GAAG;MACH,QAAQ,KAAK,UAAU;KACxB;EACH;;;;ACNI,IAAO,OAAP,cAAoB,YAAW;EAArC,cAAA;;AACE,SAAA,cAA0C,IAAmB,YAAY,KAAK,OAAO;EACvF;;AAEA,KAAK,cAAc;;;AC5Bb,IAAOC,eAAP,cAA2B,YAAW;;;;ACCtC,IAAO,aAAP,cAA0B,YAAW;;;;EAIzC,OACE,MACA,SAA6B;AAE7B,WAAO,KAAK,QAAQ,KAAK,yBAAyB,EAAE,MAAM,GAAG,QAAO,CAAE;EACxE;;;;ACTI,IAAO,QAAP,cAAqB,YAAW;;;;;;;;;EASpC,OAAO,MAAwB,SAA6B;AAC1D,WAAO,KAAK,QAAQ,KAAK,oBAAyB,4BAA4B,EAAE,MAAM,GAAG,QAAO,CAAE,CAAC;EACrG;;;;EAKA,KAAK,SAA6B;AAChC,WAAO,KAAK,QAAQ,IAAI,oBAAoB,OAAO;EACrD;;;;EAKA,OAAO,QAAgB,SAA6B;AAClD,WAAO,KAAK,QAAQ,OAAO,oBAAoB,MAAM,IAAI,OAAO;EAClE;;;;EAKA,QAAQ,QAAgB,SAA6B;AACnD,WAAO,KAAK,QAAQ,IAAI,oBAAoB,MAAM,YAAY,OAAO;EACvE;;;;EAKA,KAAK,QAAgB,SAA6B;AAChD,WAAO,KAAK,QAAQ,IAAI,oBAAoB,MAAM,IAAI,OAAO;EAC/D;;;;ACvCI,IAAO,SAAP,cAAsB,YAAW;;;;EAIrC,SAAS,OAAe,SAA6B;AACnD,WAAO,KAAK,QAAQ,IAAI,qBAAqB,KAAK,IAAI,OAAO;EAC/D;;;;EAKA,KAAK,SAA6B;AAChC,WAAO,KAAK,QAAQ,IAAI,qBAAqB,OAAO;EACtD;;;;EAKA,OAAO,OAAe,SAA6B;AACjD,WAAO,KAAK,QAAQ,OAAO,qBAAqB,KAAK,IAAI,OAAO;EAClE;;;;;ACiFI,IAAO,OAAP,cAAyB,UAAS;;;;;;;;;;;;;;EAkBtC,YAAY,EACV,UAAe,QAAQ,eAAe,GACtC,SAAc,QAAQ,cAAc,GACpC,GAAG,KAAI,IACU,CAAA,GAAE;AACnB,QAAI,WAAW,QAAW;AACxB,YAAM,IAAW,UACf,8KAA8K;;AAIlL,UAAM,UAAyB;MAC7B;MACA,GAAG;MACH,SAAS,WAAW;;AAGtB,QAAI,CAAC,QAAQ,2BAAgC,mBAAkB,GAAI;AACjE,YAAM,IAAW,UACf,8VAA8V;;AAIlW,UAAM;MACJ,SAAS,QAAQ;MACjB,SAAS,QAAQ,WAAW;MAC5B,WAAW,QAAQ;MACnB,YAAY,QAAQ;MACpB,OAAO,QAAQ;KAChB;AAOH,SAAA,cAA+B,IAAQC,aAAY,IAAI;AACvD,SAAA,OAAiB,IAAQ,KAAK,IAAI;AAClC,SAAA,aAA6B,IAAQ,WAAW,IAAI;AACpD,SAAA,QAAmB,IAAQ,MAAM,IAAI;AACrC,SAAA,SAAqB,IAAQ,OAAO,IAAI;AACxC,SAAA,UAAuB,IAAQ,QAAQ,IAAI;AAC3C,SAAA,QAAmB,IAAQ,MAAM,IAAI;AAXnC,SAAK,WAAW;AAEhB,SAAK,SAAS;EAChB;EAUmB,eAAY;AAC7B,WAAO,KAAK,SAAS;EACvB;EAEmB,eAAe,MAA8B;AAC9D,WAAO;MACL,GAAG,MAAM,eAAe,IAAI;MAC5B,GAAG,KAAK,SAAS;;EAErB;EAEmB,YAAY,MAA8B;AAC3D,WAAO,EAAE,eAAe,UAAU,KAAK,MAAM,GAAE;EACjD;;;AAEO,KAAA,OAAO;AACP,KAAA,kBAAkB;AAElB,KAAA,YAAmB;AACnB,KAAA,WAAkB;AAClB,KAAA,qBAA4B;AAC5B,KAAA,4BAAmC;AACnC,KAAA,oBAA2B;AAC3B,KAAA,gBAAuB;AACvB,KAAA,gBAAuB;AACvB,KAAA,iBAAwB;AACxB,KAAA,kBAAyB;AACzB,KAAA,sBAA6B;AAC7B,KAAA,sBAA6B;AAC7B,KAAA,wBAA+B;AAC/B,KAAA,2BAAkC;AAElC,KAAA,SAAiB;AACjB,KAAA,eAAuB;AAGhC,KAAK,cAAcA;AACnB,KAAK,OAAO;AACZ,KAAK,aAAa;AAClB,KAAK,QAAQ;AACb,KAAK,SAAS;AACd,KAAK,UAAU;AACf,KAAK,QAAQ;AAgEb,IAAA,mBAAe;",
  "names": ["fetch", "Request", "Response", "Headers", "FormData", "Blob", "File", "ReadableStream", "ReadableStream", "_a", "File", "_a", "FormData", "fetch", "opts", "_a", "retryMessage", "_a", "_a", "_a", "_a", "Completions", "Completions"]
}
